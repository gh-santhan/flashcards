<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flashcards – Minimal SRS</title>
<style>
  :root{
    --bg:#0f1115; --card:#12151b; --ink:#e7e9ee; --muted:#9aa3b2; --line:#1d2230;
    --btn:#191d27; --accent:#22d3ee; --ok:#16a34a; --hard:#ea580c; --bad:#dc2626; --info:#3b82f6;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:400 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
  .wrap{max-width:980px;margin:0 auto;padding:18px}
  header{display:flex;align-items:center;gap:10px;margin-bottom:12px}
  h1{margin:0;font-size:18px;font-weight:600}
  #menuBtn{margin-left:auto;background:var(--btn);border:1px solid var(--line);color:var(--ink);border-radius:8px;padding:6px 10px;cursor:pointer}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .stack{display:flex;flex-direction:column;gap:10px}
  select,input[type="text"],button{border-radius:8px;border:1px solid var(--line);background:var(--btn);color:var(--ink)}
  select,input[type="text"]{padding:8px 10px}
  button{padding:9px 12px;cursor:pointer}
  button:hover{border-color:#2a3248}
  .muted{color:var(--muted)}
  .counts{display:flex;gap:8px;align-items:center;margin:10px 0 6px}
  .pill{border:1px solid var(--line);border-radius:999px;padding:4px 10px;display:flex;gap:6px;align-items:center}
  .pill b{font-variant-numeric:tabular-nums}
  .pill.again{border-color:#7f1d1d;background:#1b1111}
  .pill.hard{border-color:#7c2d12;background:#1b130e}
  .pill.good{border-color:#14532d;background:#0e1a14}
  .pill.easy{border-color:#1e3a8a;background:#0d1525}
  .pill.total{border-color:#2a3248;background:#11141c}
  .filters{display:flex;gap:10px;align-items:center;margin:6px 0 12px}
  .card{
    background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px 16px 14px;
  }
  .meta{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;color:var(--muted);font-size:14px}
  .front,.back{white-space:pre-wrap}
  .front{font-size:18px;line-height:1.6}
  .back{display:none;margin-top:10px;opacity:.98}
  .btnbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .primary{background:#1a2335;border-color:#2a3248}
  .ok{background:rgba(22,163,74,.08);border-color:#14532d}
  .hard{background:rgba(234,88,12,.08);border-color:#7c2d12}
  .bad{background:rgba(220,38,38,.08);border-color:#7f1d1d}
  .easy{background:rgba(37,99,235,.08);border-color:#1e3a8a}
  .ghost{background:#0b0f18}
  .tagline{margin-top:10px;display:flex;gap:8px;flex-wrap:wrap}
  .tag{background:#0b0f18;border:1px solid var(--line);border-radius:999px;padding:3px 8px;font-size:12px}
  .tag input{background:transparent;border:none;color:var(--ink);outline:none}
  .section{margin-top:14px}
  .searchRow{display:flex;gap:8px;align-items:center}
  .help{font-size:13px;color:var(--muted)}
  /* Menu */
  .menu{position:fixed;top:56px;right:18px;background:var(--card);border:1px solid var(--line);border-radius:10px;padding:10px;display:none;min-width:240px;z-index:20}
  .menu a, .menu button{display:block;width:100%;text-align:left;background:transparent;border:1px solid transparent;padding:8px;border-radius:8px}
  .menu a:hover, .menu button:hover{background:#0b0f18;border-color:#2a3248}
  /* Modal (solid black bg) */
  .modal{position:fixed;inset:0;background:#000;display:none;z-index:50;color:#eaecef}
  .modal .box{max-width:1100px;margin:40px auto;background:#0d1117;border:1px solid #222a3a;border-radius:12px;display:grid;grid-template-columns:320px 1fr;min-height:540px;overflow:hidden}
  .modal header{padding:10px 12px;border-bottom:1px solid #222a3a}
  .modal .left{border-right:1px solid #222a3a;display:flex;flex-direction:column}
  .modal .left .searchbar{padding:10px;border-bottom:1px solid #222a3a}
  .modal .left input{width:100%;background:#0b0f18;border:1px solid #222a3a}
  .modal .left .results{flex:1;overflow:auto}
  .modal .item{padding:10px 12px;border-bottom:1px solid #141a24;cursor:pointer}
  .modal .item:hover{background:#0b0f18}
  .modal .item .small{color:#99a3b3;font-size:12px}
  .modal .right{padding:12px;display:flex;flex-direction:column}
  .modal .preview{flex:1;border:1px solid #222a3a;border-radius:10px;padding:12px;background:#0b0f18}
  .modal .btns{margin-top:10px;display:flex;gap:8px;flex-wrap:wrap}
  .solid-accent{background:#122231;border-color:#224062}
  .hidden{display:none}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Flashcards</h1>
    <button id="menuBtn" aria-label="Menu">☰ Menu</button>
  </header>

  <!-- Deck selector below heading -->
  <div class="row">
    <label class="muted" for="deckSelect">Deck</label>
    <select id="deckSelect" aria-label="Select deck"></select>
  </div>

  <!-- Card count + difficulty counters -->
  <div class="counts">
    <div class="pill total"><span>Total</span> <b id="totalCount">0</b></div>
    <div class="pill again"><span>Again</span> <b id="cntAgain">0</b></div>
    <div class="pill hard"><span>Hard</span> <b id="cntHard">0</b></div>
    <div class="pill good"><span>Good</span> <b id="cntGood">0</b></div>
    <div class="pill easy"><span>Easy</span> <b id="cntEasy">0</b></div>
    <div class="pill"><span>Ungraded</span> <b id="cntNone">0</b></div>
  </div>

  <!-- Card UI -->
  <div class="card">
    <div class="meta">
      <div id="metaLeft" class="muted">—</div>
      <div id="metaRight" class="muted">—</div>
    </div>
    <div id="front" class="front"></div>
    <div id="back" class="back"></div>

    <div class="btnbar">
      <button id="revealBtn" class="primary">Reveal</button>
      <button id="prevBtn" class="ghost">◀ Prev</button>
      <button id="nextBtn" class="ghost">Next ▶</button>

      <span id="afterReveal" class="hidden" style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="suspendBtn" class="ghost">Suspend</button>
        <button id="gradeAgain" class="bad">Again (1)</button>
        <button id="gradeHard" class="hard">Hard (2)</button>
        <button id="gradeGood" class="ok">Good (3)</button>
        <button id="gradeEasy" class="easy">Easy (4)</button>
      </span>
    </div>

    <!-- Tags editor -->
    <div class="tagline" id="tagline"></div>
    <div class="row">
      <input id="addTagInput" type="text" placeholder="Add tag then press Enter" aria-label="Add tag"/>
      <button id="clearTagsBtn" class="ghost">Clear tags (card)</button>
    </div>
  </div>

  <!-- Search & difficulty filter (only) -->
  <div class="section">
    <div class="row">
      <div class="searchRow">
        <input id="searchText" type="text" placeholder="Search keyword or #tag across ALL decks" aria-label="Search text"/>
        <button id="searchBtn" class="solid-accent">Search</button>
      </div>
      <div class="row" style="margin-left:auto">
        <label class="muted" for="diffFilter">Difficulty</label>
        <select id="diffFilter" aria-label="Difficulty filter">
          <option value="all">All</option>
          <option value="again">Again</option>
          <option value="hard">Hard</option>
          <option value="good">Good</option>
          <option value="easy">Easy</option>
          <option value="none">Ungraded</option>
        </select>
      </div>
    </div>
    <div class="help">Tip: use <code>#tag</code> in search to match tags across all decks. Press <b>/</b> to focus search.</div>
  </div>
</div>

<!-- Menu -->
<div class="menu" id="menu">
  <button id="downloadDeckBtn">Download current deck</button>
  <button id="uploadDeckBtn">Upload deck (JSON)</button>
  <button id="backupBtn">Download backup (settings + grades + tags)</button>
  <button id="restoreBtn">Restore backup JSON</button>
  <hr style="border:none;border-top:1px solid var(--line);margin:8px 0">
  <div class="muted" style="padding:6px 8px;font-size:13px">Manifest</div>
  <button id="reloadManifestBtn">Reload manifest</button>
  <div class="muted" id="manifestInfo" style="padding:6px 8px;font-size:12px"></div>
  <input id="fileInput" type="file" accept=".json,application/json" style="display:none"/>
</div>

<!-- Search Modal -->
<div class="modal" id="searchModal" aria-hidden="true">
  <div class="box">
    <div class="left">
      <header class="row" style="justify-content:space-between;width:100%">
        <strong>Search</strong>
        <button id="closeSearch" class="ghost">✕ Close</button>
      </header>
      <div class="searchbar">
        <input id="modalSearchInput" type="text" placeholder="Type to search across all decks…"/>
      </div>
      <div class="results" id="resultsList"></div>
    </div>
    <div class="right">
      <div class="preview" id="previewBox">
        <div class="muted" id="previewMeta">—</div>
        <div id="previewFront" style="margin-top:8px;white-space:pre-wrap"></div>
        <div id="previewBack" style="margin-top:8px;white-space:pre-wrap"></div>
      </div>
      <div class="btns">
        <button id="prevResult" class="ghost">◀ Prev</button>
        <button id="nextResult" class="ghost">Next ▶</button>
        <button id="openResult" class="solid-accent">Open in main</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // ---------- Config / storage keys ----------
  const DEFAULT_MANIFEST = "decks.json";
  const MANIFEST_URL = new URLSearchParams(location.search).get("manifest") || DEFAULT_MANIFEST;
  const SETTINGS_KEY = "srs.min.settings.v1";
  const GRADES_KEY   = "srs.min.grades.v1";     // { cardId: "again"|"hard"|"good"|"easy" }
  const SUSP_KEY     = "srs.min.suspended.v1";  // Set of cardIds
  const TAGS_KEY     = "srs.min.tags.v1";       // { cardId: ["tag", ...] }

  // ---------- State ----------
  let manifest = {decks:[]};
  let deck = { name:"", cards:[] };
  let deckURL = null;
  let order = []; // filtered indices (respecting difficulty filter and suspended)
  let idx = 0;

  // Cross-deck caches for search
  const deckCache = new Map(); // url -> {name,cards}
  const allDecksLoaded = new Map(); // name -> data

  // Persistent maps
  const grades = loadJSON(GRADES_KEY, {}); // cardId -> diff
  const suspended = new Set(loadJSON(SUSP_KEY, []));
  const tagOver = loadJSON(TAGS_KEY, {});  // overrides

  const settings = Object.assign({
    lastDeckURL: null,
    diffFilter: "all"
  }, loadJSON(SETTINGS_KEY, {}));

  // ---------- Elements ----------
  const $ = (id)=>document.getElementById(id);
  const els = {
    deckSelect: $("deckSelect"),
    total: $("totalCount"),
    cntAgain: $("cntAgain"), cntHard: $("cntHard"), cntGood: $("cntGood"), cntEasy: $("cntEasy"), cntNone: $("cntNone"),
    metaLeft: $("metaLeft"), metaRight: $("metaRight"),
    front: $("front"), back: $("back"),
    reveal: $("revealBtn"), prev: $("prevBtn"), next: $("nextBtn"),
    after: $("afterReveal"), suspend: $("suspendBtn"),
    gAgain: $("gradeAgain"), gHard: $("gradeHard"), gGood: $("gradeGood"), gEasy: $("gradeEasy"),
    tagLine: $("tagline"), addTagInput: $("addTagInput"), clearTagsBtn: $("clearTagsBtn"),
    diffFilter: $("diffFilter"),
    searchText: $("searchText"), searchBtn: $("searchBtn"),
    menuBtn: $("menuBtn"), menu: $("menu"), fileInput: $("fileInput"),
    downloadDeckBtn: $("downloadDeckBtn"), uploadDeckBtn: $("uploadDeckBtn"),
    backupBtn: $("backupBtn"), restoreBtn: $("restoreBtn"), reloadManifestBtn: $("reloadManifestBtn"),
    manifestInfo: $("manifestInfo"),
    // Search modal
    modal: $("searchModal"), closeSearch: $("closeSearch"), modalInput: $("modalSearchInput"),
    resultsList: $("resultsList"), previewFront: $("previewFront"), previewBack: $("previewBack"),
    previewMeta: $("previewMeta"), prevResult: $("prevResult"), nextResult: $("nextResult"), openResult: $("openResult"),
  };

  // Search state
  let results = []; // [{deckName, deckURL, index, card, id}]
  let rIdx = 0;

  // ---------- Utils ----------
  function loadJSON(k, fallback){ try{ return JSON.parse(localStorage.getItem(k) || JSON.stringify(fallback)); }catch{return fallback} }
  function saveJSON(k, v){ localStorage.setItem(k, JSON.stringify(v)); }
  function esc(s){ return String(s ?? "").replace(/[&<>]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;'})[c]); }
  const tagify = (tags)=>Array.isArray(tags)? tags : (typeof tags==="string"? tags.split(",").map(s=>s.trim()).filter(Boolean) : []);

  function cardId(dName, i){ return `${dName}::${i}`; }

  async function fetchJSON(url){
    const res = await fetch(url, {cache:"no-store"});
    if(!res.ok) throw new Error(`Fetch ${res.status} for ${url}`);
    return res.json();
  }

  // ---------- Manifest & deck loading ----------
  async function loadManifest(){
    const m = await fetchJSON(MANIFEST_URL);
    if(!m || !Array.isArray(m.decks)) throw new Error("Manifest missing 'decks' array");
    manifest = m;
    els.manifestInfo.textContent = `Manifest: ${MANIFEST_URL}`;
    // populate select
    els.deckSelect.innerHTML = "";
    const base = new URL(MANIFEST_URL, location.href);
    manifest.decks.forEach(d=>{
      const opt = document.createElement("option");
      opt.value = new URL(d.file, base).href;
      opt.textContent = d.name || d.file;
      els.deckSelect.appendChild(opt);
    });
    if(settings.lastDeckURL){
      const found = [...els.deckSelect.options].find(o=>o.value===settings.lastDeckURL);
      if(found) els.deckSelect.value = found.value;
    }
    if(!els.deckSelect.value && els.deckSelect.options.length) els.deckSelect.selectedIndex = 0;
    if(els.deckSelect.value) await switchDeck(els.deckSelect.value);
  }

  async function getDeck(url){
    if(deckCache.has(url)) return deckCache.get(url);
    const data = await fetchJSON(url);
    if(!data || !Array.isArray(data.cards)) throw new Error(`Deck JSON missing 'cards' (${url})`);
    // assign ids
    const d = JSON.parse(JSON.stringify(data));
    d.cards.forEach((c,i)=> c.__id = cardId(d.name||"deck", i));
    deckCache.set(url, d);
    allDecksLoaded.set(d.name||url, {url, data:d});
    return d;
  }

  async function switchDeck(url){
    const d = await getDeck(url);
    deck = d;
    deckURL = url;
    settings.lastDeckURL = url; saveJSON(SETTINGS_KEY, settings);
    // ensure tag overrides applied
    deck.cards.forEach(c=>{
      if(tagOver[c.__id]) c.Tags = tagOver[c.__id];
    });
    rebuildOrder(); renderCard(); renderCounts();
  }

  // ---------- Filtering (by difficulty + suspended only) ----------
  function matchesDiff(c){
    const id = c.__id;
    const g = grades[id] || "none";
    const want = settings.diffFilter || "all";
    if(want === "all") return true;
    return g === want;
  }
  function rebuildOrder(){
    order = deck.cards.map((c,i)=>({c,i}))
      .filter(({c})=> !suspended.has(c.__id) )
      .filter(({c})=> matchesDiff(c))
      .map(({i})=>i);
    idx = Math.min(idx, Math.max(0, order.length-1));
    if(order.length===0) idx = 0;
  }

  // ---------- Counters ----------
  function renderCounts(){
    const tot = deck.cards.length;
    let a=0,h=0,g=0,e=0,n=0;
    deck.cards.forEach(c=>{
      const val = grades[c.__id] || "none";
      if(val==="again") a++; else if(val==="hard") h++; else if(val==="good") g++; else if(val==="easy") e++; else n++;
    });
    els.total.textContent = tot;
    els.cntAgain.textContent = a; els.cntHard.textContent = h; els.cntGood.textContent = g; els.cntEasy.textContent = e; els.cntNone.textContent = n;
  }

  // ---------- Render card ----------
  function curCard(){
    if(!order.length) return null;
    const i = order[idx];
    return {i, c: deck.cards[i]};
  }
  function renderTags(c){
    const tags = tagify(c.Tags);
    els.tagLine.innerHTML = tags.map(t=>`<span class="tag">#${esc(t)}</span>`).join("") || `<span class="muted">No tags</span>`;
  }
  function renderCard(){
    const cur = curCard();
    if(!cur){
      els.metaLeft.textContent = deck.name || "—";
      els.metaRight.textContent = "0 / 0";
      els.front.textContent = "No cards match your current difficulty filter.";
      els.back.style.display = "none";
      els.after.classList.add("hidden");
      els.tagLine.innerHTML = "";
      return;
    }
    const {i,c} = cur;
    const totalShown = order.length;
    els.metaLeft.textContent = `${deck.name} — ${grades[c.__id] ? ('Last: '+grades[c.__id]) : 'Ungraded'} ${suspended.has(c.__id)? ' (Suspended)':''}`;
    els.metaRight.textContent = `${idx+1} / ${totalShown}`;
    els.front.innerHTML = String(c.Front || "");
    els.back.innerHTML  = String(c.Back || "");
    els.back.style.display = "none";
    els.after.classList.add("hidden");
    renderTags(c);
  }

  // ---------- Actions ----------
  function reveal(){
    if(!curCard()) return;
    els.back.style.display = "block";
    els.after.classList.remove("hidden");
  }
  function step(delta){
    if(!order.length) return;
    idx = (idx + delta + order.length) % order.length;
    renderCard();
  }
  function grade(kind){
    const cur = curCard(); if(!cur) return;
    const id = cur.c.__id;
    grades[id] = kind;
    saveJSON(GRADES_KEY, grades);
    renderCounts();
    step(1);
  }
  function toggleSuspend(){
    const cur = curCard(); if(!cur) return;
    const id = cur.c.__id;
    if(suspended.has(id)) suspended.delete(id); else suspended.add(id);
    saveJSON(SUSP_KEY, [...suspended]);
    rebuildOrder(); renderCounts(); renderCard();
  }
  function addTag(){
    const cur = curCard(); if(!cur) return;
    const raw = els.addTagInput.value.trim();
    if(!raw) return;
    const newTags = raw.split(",").map(s=>s.trim()).filter(Boolean);
    const id = cur.c.__id;
    const prev = tagify(cur.c.Tags);
    const merged = Array.from(new Set([...prev, ...newTags]));
    cur.c.Tags = merged;
    tagOver[id] = merged;
    saveJSON(TAGS_KEY, tagOver);
    els.addTagInput.value = "";
    renderTags(cur.c);
  }
  function clearTags(){
    const cur = curCard(); if(!cur) return;
    const id = cur.c.__id;
    cur.c.Tags = [];
    tagOver[id] = [];
    saveJSON(TAGS_KEY, tagOver);
    renderTags(cur.c);
  }

  // Difficulty filter change
  function setDiffFilter(v){
    settings.diffFilter = v;
    saveJSON(SETTINGS_KEY, settings);
    rebuildOrder();
    renderCard();
  }

  // ---------- Search (modal, across all decks) ----------
  async function ensureAllDecksLoaded(){
    const base = new URL(MANIFEST_URL, location.href);
    // fetch all decks not yet loaded
    for(const d of manifest.decks){
      const url = new URL(d.file, base).href;
      if(!deckCache.has(url)) await getDeck(url);
    }
  }
  function queryResults(q){
    // q may have #tag tokens; do simple search across name/Front/Back/Tags
    q = q.trim();
    const tagTokens = q.split(/\s+/).filter(t=>t.startsWith("#")).map(t=>t.slice(1).toLowerCase());
    const text = q.replace(/#[^\s]+/g,"").trim().toLowerCase();

    const out = [];
    for(const [name, {url, data}] of allDecksLoaded.entries()){
      data.cards.forEach((c,i)=>{
        const id = c.__id;
        const tags = tagify(c.Tags).map(s=>s.toLowerCase());
        const textHit = !text || (String(c.Front||"").toLowerCase().includes(text) || String(c.Back||"").toLowerCase().includes(text));
        const tagHit = !tagTokens.length || tagTokens.every(t => tags.includes(t));
        if(textHit && tagHit){
          out.push({deckName:name, deckURL:url, index:i, card:c, id});
        }
      });
    }
    return out;
  }
  function openSearchModal(initial=""){
    els.modal.style.display = "block";
    els.modal.setAttribute("aria-hidden","false");
    els.modalInput.value = initial || els.searchText.value || "";
    els.modalInput.focus();
    updateSearchResults();
  }
  function closeSearchModal(){
    els.modal.style.display = "none";
    els.modal.setAttribute("aria-hidden","true");
  }
  function updateSearchResults(){
    const q = els.modalInput.value;
    results = queryResults(q);
    rIdx = 0;
    renderResultsList();
    renderResultPreview();
  }
  function renderResultsList(){
    els.resultsList.innerHTML = results.map((r,i)=>`
      <div class="item" data-i="${i}">
        <div><strong>${esc(r.deckName)}</strong> — #${r.index+1}</div>
        <div class="small">${esc(String(r.card.Front).slice(0,120))}${String(r.card.Front).length>120?"…":""}</div>
      </div>
    `).join("") || `<div class="item"><div>No matches.</div></div>`;
  }
  function renderResultPreview(){
    if(!results.length){
      els.previewMeta.textContent = "—";
      els.previewFront.textContent = "";
      els.previewBack.textContent = "";
      return;
    }
    const r = results[rIdx];
    els.previewMeta.textContent = `${r.deckName} — card ${r.index+1} / ${allDecksLoaded.get(r.deckName).data.cards.length}`;
    els.previewFront.innerHTML = String(r.card.Front||"");
    els.previewBack.innerHTML  = String(r.card.Back||"");
    // highlight selected in list
    [...els.resultsList.children].forEach((el,i)=>{
      el.style.background = i===rIdx ? "#101828" : "transparent";
    });
  }
  function openResultInMain(){
    if(!results.length) return;
    const r = results[rIdx];
    // switch deck if needed, then jump to index
    switchDeck(r.deckURL).then(()=>{
      // set filter to show this card even if filter hides it
      settings.diffFilter = "all"; els.diffFilter.value = "all"; saveJSON(SETTINGS_KEY, settings);
      rebuildOrder();
      // find its position in order
      const pos = order.indexOf(r.index);
      idx = pos>=0 ? pos : 0;
      renderCard(); renderCounts();
      closeSearchModal();
    });
  }

  // ---------- Import/Export ----------
  function download(name, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = name; a.click(); URL.revokeObjectURL(a.href);
  }

  // ---------- Events ----------
  els.deckSelect.addEventListener("change", e=> switchDeck(e.target.value));
  els.reveal.addEventListener("click", reveal);
  els.prev.addEventListener("click", ()=> step(-1));
  els.next.addEventListener("click", ()=> step(+1));
  els.suspend.addEventListener("click", toggleSuspend);
  els.gAgain.addEventListener("click", ()=> grade("again"));
  els.gHard .addEventListener("click", ()=> grade("hard"));
  els.gGood .addEventListener("click", ()=> grade("good"));
  els.gEasy .addEventListener("click", ()=> grade("easy"));

  els.addTagInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); addTag(); }});
  els.clearTagsBtn.addEventListener("click", clearTags);

  els.diffFilter.value = settings.diffFilter || "all";
  els.diffFilter.addEventListener("change", (e)=> setDiffFilter(e.target.value));

  // Search
  document.addEventListener("keydown", (e)=>{ if(e.key === "/"){ e.preventDefault(); els.searchText.focus(); }});
  els.searchBtn.addEventListener("click", ()=> openSearchModal());
  els.searchText.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ openSearchModal(); }});

  els.closeSearch.addEventListener("click", closeSearchModal);
  els.modalInput.addEventListener("input", updateSearchResults);
  els.resultsList.addEventListener("click", (e)=>{
    const item = e.target.closest(".item"); if(!item) return;
    rIdx = Number(item.dataset.i)||0;
    renderResultPreview();
  });
  els.prevResult.addEventListener("click", ()=>{ if(!results.length) return; rIdx=(rIdx-1+results.length)%results.length; renderResultPreview(); });
  els.nextResult.addEventListener("click", ()=>{ if(!results.length) return; rIdx=(rIdx+1)%results.length; renderResultPreview(); });
  els.openResult.addEventListener("click", openResultInMain);

  // Menu
  els.menuBtn.addEventListener("click", ()=>{
    els.menu.style.display = (els.menu.style.display==="block" ? "none" : "block");
  });
  document.addEventListener("click", (e)=>{
    if(e.target.id==="menuBtn" || e.target.closest("#menu")) return;
    els.menu.style.display = "none";
  });

  els.downloadDeckBtn.addEventListener("click", ()=> download(`${(deck.name||"deck").replace(/\s+/g,'-').toLowerCase()}.json`, deck));
  els.uploadDeckBtn.addEventListener("click", ()=> els.fileInput.click());
  els.fileInput.addEventListener("change", (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    const r = new FileReader();
    r.onload = ()=>{
      try{
        const data = JSON.parse(r.result);
        if(data.cards){
          // Load as current deck (local)
          deck = data; deck.cards.forEach((c,i)=> c.__id = cardId(deck.name||"deck", i));
          deckURL = null; settings.lastDeckURL=null; saveJSON(SETTINGS_KEY, settings);
          rebuildOrder(); renderCard(); renderCounts();
        }else if(data.decks){
          manifest = data;
          // Rebuild deck select from local manifest (relative URLs won't work from file://)
          els.deckSelect.innerHTML = "";
          manifest.decks.forEach(d=>{
            const opt = document.createElement("option");
            opt.value = d.file;
            opt.textContent = d.name || d.file;
            els.deckSelect.appendChild(opt);
          });
        }else throw new Error("JSON is neither a deck nor a manifest");
      }catch(err){ alert("Import failed: "+err.message); }
    };
    r.readAsText(f);
  });

  els.backupBtn.addEventListener("click", ()=>{
    const payload = {
      settings, grades, suspended:[...suspended], tags: tagOver, timestamp:new Date().toISOString()
    };
    download("flashcards-backup.json", payload);
  });
  els.restoreBtn.addEventListener("click", ()=>{
    const inp = document.createElement("input");
    inp.type="file"; inp.accept=".json,application/json";
    inp.onchange = e=>{
      const f = e.target.files?.[0]; if(!f) return;
      const r = new FileReader();
      r.onload = ()=>{
        try{
          const data = JSON.parse(r.result);
          if(data.settings) Object.assign(settings, data.settings);
          if(data.grades) Object.assign(grades, data.grades);
          if(Array.isArray(data.suspended)){ suspended.clear(); data.suspended.forEach(x=>suspended.add(x)); }
          if(data.tags) Object.assign(tagOver, data.tags);
          saveJSON(SETTINGS_KEY, settings); saveJSON(GRADES_KEY, grades); saveJSON(SUSP_KEY, [...suspended]); saveJSON(TAGS_KEY, tagOver);
          rebuildOrder(); renderCounts(); renderCard();
          alert("Backup restored.");
        }catch(err){ alert("Restore failed: "+err.message); }
      };
      r.readAsText(f);
    };
    inp.click();
  });
  els.reloadManifestBtn.addEventListener("click", ()=> loadManifest());

  // Keyboard shortcuts on main card
  document.addEventListener("keydown", (e)=>{
    if(e.key===" "){ e.preventDefault(); if(els.back.style.display==="block") step(+1); else reveal(); }
    if(e.key==="ArrowRight"){ step(+1); }
    if(e.key==="ArrowLeft"){ step(-1); }
    if(e.key==="1"){ grade("again"); }
    if(e.key==="2"){ grade("hard"); }
    if(e.key==="3"){ grade("good"); }
    if(e.key==="4"){ grade("easy"); }
  });

  // Close modal on ESC
  document.addEventListener("keydown", (e)=>{ if(e.key==="Escape" && els.modal.style.display==="block") closeSearchModal(); });

  // ---------- Init ----------
  (async function init(){
    els.diffFilter.value = settings.diffFilter || "all";
    // Load manifest & default deck
    try{
      await loadManifest();
      // Preload all decks for search when opening modal (on demand)
      els.searchBtn.addEventListener("click", async ()=>{ await ensureAllDecksLoaded(); openSearchModal(); });
      els.modalInput.addEventListener("focus", ensureAllDecksLoaded, {once:true});
    }catch(err){
      alert("Failed to load manifest: "+err.message);
    }
  })();

})();
</script>
</body>
</html>
