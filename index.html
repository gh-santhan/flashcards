<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flashcards</title>
  <style>
    :root{--bg:#f6f7fb;--card:#fff;--ink:#111827;--muted:#6b7280;--accent:#2563eb;--border:#e5e7eb}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--ink);background:var(--bg)}
    header{position:sticky;top:0;z-index:5;background:#fff;padding:14px 16px;box-shadow:0 1px 6px rgba(0,0,0,.06)}
    h1{margin:0 0 8px;font-size:20px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    select,input[type="text"],button,label{font-size:14px}
    input[type="text"],select{padding:8px 10px;border:1px solid var(--border);border-radius:8px;background:#fff}
    button{padding:8px 12px;border:1px solid var(--border);background:#fff;border-radius:8px;cursor:pointer}
    button.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
    button.ghost{background:transparent;border-color:transparent;color:var(--accent)}
    main{padding:18px;max-width:1100px;margin:0 auto}
    .grid{display:grid;grid-template-columns:1fr 320px;gap:18px;align-items:start}
    #card{background:var(--card);border-radius:12px;padding:18px;box-shadow:0 6px 24px rgba(0,0,0,.06);min-height:230px;cursor:pointer}
    #front{font-size:18px;line-height:1.5;white-space:pre-wrap}
    #back{font-size:16px;line-height:1.6;margin-top:12px;display:none;white-space:pre-wrap}
    .meta{margin-top:10px;font-size:12px;color:var(--muted)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    .panel{background:#fff;border-radius:12px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.06)}
    .panel h3{margin:0 0 8px;font-size:14px}
    .sep{height:1px;background:var(--border);margin:12px 0}
    .muted{color:var(--muted);font-size:12px}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid var(--border);margin:2px 4px 0 0;font-size:12px}
    .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#f3f4f6;border:1px solid #e5e7eb;border-radius:6px;padding:0 6px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <header>
    <h1>Flashcards</h1>
    <div class="row">
      <select id="deckSelect"></select>
      <button id="refreshBtn">Refresh decks</button>

      <input id="searchBox" type="text" placeholder="Global search (Q & A)" />
      <input id="tagSearchBox" type="text" placeholder="Filter by tag" />

      <select id="difficultySelect">
        <option value="any">All</option>
        <option value="Ungraded">Ungraded</option>
        <option value="Again">Again</option>
        <option value="Hard">Hard</option>
        <option value="Good">Good</option>
        <option value="Easy">Easy</option>
      </select>

      <select id="statusSelect">
        <option value="active">Active</option>
        <option value="suspended">Suspended</option>
        <option value="all">All cards</option>
      </select>

      <button id="exportBtn" class="ghost">Export progress</button>
      <label class="ghost">Import progress
        <input id="importInput" type="file" accept="application/json" style="display:none" />
      </label>
    </div>
  </header>

  <main>
    <div class="grid">
      <div>
        <div id="card" onclick="flipCard()">
          <div id="front"></div>
          <div id="back"></div>
          <div class="meta" id="meta"></div>
        </div>

        <div class="controls">
          <button onclick="prevCard()"><span class="kbd">←</span> Previous</button>
          <button onclick="nextCard()">Next <span class="kbd">→</span></button>
          <button onclick="flipCard()"><span class="kbd">Space</span> Flip</button>
        </div>

        <div class="controls">
          <button onclick="grade('again')"><span class="kbd">1</span> Again</button>
          <button onclick="grade('hard')"><span class="kbd">2</span> Hard</button>
          <button onclick="grade('good')"><span class="kbd">3</span> Good</button>
          <button onclick="grade('easy')"><span class="kbd">4</span> Easy</button>
          <button onclick="toggleSuspend()"><span class="kbd">S</span> Suspend</button>
        </div>

        <div class="controls">
          <input id="addTagInput" type="text" placeholder="Add custom tag to this card" />
          <button onclick="addCustomTag()">Add tag</button>
        </div>
        <div class="muted">Your grading, suspensions, and custom tags are stored in your browser. Use Export/Import to back them up or move devices.</div>
      </div>

      <div class="panel">
        <h3>Deck Stats</h3>
        <div id="counts">Loading…</div>
        <div class="sep"></div>
        <div class="muted">
          Shortcuts: <span class="kbd">←</span>/<span class="kbd">→</span> navigate, <span class="kbd">Space</span> flip,
          <span class="kbd">1</span>/<span class="kbd">2</span>/<span class="kbd">3</span>/<span class="kbd">4</span> grade,
          <span class="kbd">S</span> suspend.
        </div>
      </div>
    </div>
  </main>

  <script>
    // ---------- Utilities ----------
    const $ = id => document.getElementById(id);
    const PROGRESS_KEY = "fc_progress_v2";

    function saveProgress(obj){ localStorage.setItem(PROGRESS_KEY, JSON.stringify(obj)); }
    function loadProgress(){
      try { return JSON.parse(localStorage.getItem(PROGRESS_KEY)) || {}; }
      catch { return {}; }
    }

    function hashId(front, back){
      const s = (front||"") + "||" + (back||"");
      let h = 2166136261 >>> 0; // FNV-1a
      for (let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h,16777619); }
      return "c_" + (h>>>0).toString(16);
    }

    // ---------- App State ----------
    let manifest = [];        // decks/decks.json
    let allCards = [];        // flattened cards with deck info/progress
    let filtered = [];        // after filters
    let idx = 0;              // current index
    let progress = loadProgress();

    // ---------- Progress helpers ----------
    function getState(deckName, card){
      const id = hashId(card.Front, card.Back);
      const k = deckName + "::" + id;
      return progress[k] || { difficulty:null, suspended:false, extraTags:[], interval:0, ease:2.5, reps:0, lapses:0, phase:"new", due:null };
    }
    function setState(deckName, card, patch){
      const id = hashId(card.Front, card.Back);
      const k = deckName + "::" + id;
      const prev = getState(deckName, card);
      progress[k] = { ...prev, ...patch };
      saveProgress(progress);
      // reflect immediately in allCards
      const i = allCards.findIndex(x => x.__k === k);
      if (i >= 0) {
        const p = progress[k];
        allCards[i].__difficulty = p.difficulty ?? null;
        allCards[i].__suspended  = !!p.suspended;
        allCards[i].__extraTags  = p.extraTags || [];
        allCards[i].__phase      = p.phase;
        allCards[i].__due        = p.due;
      }
    }
    function userDifficulty(deckName, card){
      return getState(deckName, card).difficulty ?? "Ungraded";
    }

    // ---------- Loading ----------
    async function loadManifest(){
      const r = await fetch("decks/decks.json", {cache:"no-store"});
      if(!r.ok) throw new Error("Cannot load decks/decks.json");
      const data = await r.json();
      manifest = data.decks || [];
    }

    async function loadAll(){
      allCards = [];
      for (const d of manifest){
        try {
          const r = await fetch("decks/" + d.file + "?t=" + Date.now());
          if(!r.ok) throw new Error("Cannot load deck: " + d.file);
          const deck = await r.json();
          const cards = Array.isArray(deck.cards) ? deck.cards : [];
          cards.forEach((card, i) => {
            const k = d.name + "::" + hashId(card.Front, card.Back);
            const p = progress[k] || {};
            allCards.push({
              ...card,
              __deck: d.name || deck.name || "Deck",
              __file: d.file,
              __k: k,
              __i: i,
              __difficulty: p.difficulty ?? null,
              __suspended: !!p.suspended,
              __extraTags: p.extraTags || [],
              __phase: p.phase || "new",
              __due: p.due || null
            });
          });
        } catch(e){ console.warn(e); }
      }
    }

    function buildDeckSelect(){
      const sel = $("deckSelect");
      sel.innerHTML = "";
      const optAll = document.createElement("option");
      optAll.value = "__ALL__";
      optAll.textContent = "All decks";
      sel.appendChild(optAll);
      manifest.forEach(d => {
        const o = document.createElement("option");
        o.value = d.file;
        o.textContent = d.name;
        sel.appendChild(o);
      });
      sel.value = "__ALL__";
    }

    // ---------- Filters ----------
    function matchDifficulty(deckName, card){
      const want = $("difficultySelect").value;
      if (want === "any") return true;
      return userDifficulty(deckName, card) === want;
    }

    function applyFilters(){
      const deckVal = $("deckSelect").value;
      const q = $("searchBox").value.trim().toLowerCase();
      const tg = $("tagSearchBox").value.trim().toLowerCase();
      const status = $("statusSelect").value;

      filtered = allCards.filter(c => {
        if (deckVal !== "__ALL__" && c.__file !== deckVal) return false;

        if (status === "active"    && c.__suspended) return false;
        if (status === "suspended" && !c.__suspended) return false;

        if (!matchDifficulty(c.__deck, c)) return false;

        // Global search in Front+Back
        const front = (c.Front||"").toLowerCase();
        const back  = (c.Back ||"").toLowerCase();
        if (q && !(front.includes(q) || back.includes(q))) return false;

        // Tag filter (built-in + custom)
        const tags = [...(c.Tags||[]), ...(c.__extraTags||[])].map(x => (x||"").toLowerCase());
        if (tg && !tags.some(t => t.includes(tg))) return false;

        return true;
      });

      idx = 0;
      render();
      renderCounts();
    }

    // ---------- Render ----------
    function render(){
      const front = $("front"), back=$("back"), meta=$("meta");
      if (filtered.length === 0){
        front.textContent = "No cards found";
        back.style.display = "none";
        back.textContent = "";
        meta.textContent = "";
        return;
      }
      const c = filtered[idx];
      front.textContent = c.Front || "";
      back.textContent  = c.Back  || "";
      back.style.display = "none";

      const prog = getState(c.__deck, c);
      const chapter = c.Chapter || "—";
      const section = c.Section || "—";
      const diff = prog.difficulty ?? "Ungraded";
      const phase = prog.suspended ? "suspended" : (prog.phase || "new");
      const dueTxt = prog.due ? new Date(prog.due).toLocaleString() : "—";
      const tags = [...(c.Tags||[]), ...(prog.extraTags||[])].join(", ");

      meta.textContent = `Deck: ${c.__deck}  |  Chapter: ${chapter}  |  Section: ${section}  |  Difficulty: ${diff}  |  Phase: ${phase}  |  Due: ${dueTxt}  |  Tags: ${tags}`;
    }

    function flipCard(){
      const back = $("back");
      back.style.display = (back.style.display === "none") ? "block" : "none";
    }
    function nextCard(){ if (filtered.length){ idx = (idx+1)%filtered.length; render(); } }
    function prevCard(){ if (filtered.length){ idx = (idx-1+filtered.length)%filtered.length; render(); } }

    // ---------- Review / SRS ----------
    function schedule(deckName, card, grade){
      const now = new Date();
      const st = getState(deckName, card);

      // save your grading label
      st.difficulty = (grade==="again") ? "Again"
                     : (grade==="hard")  ? "Hard"
                     : (grade==="good")  ? "Good"
                     : (grade==="easy")  ? "Easy"
                     : (st.difficulty ?? "Ungraded");

      // simple SRS
      if (grade === "again"){
        st.lapses = (st.lapses||0)+1;
        st.reps = Math.max(0,(st.reps||0)-1);
        st.interval = 0;
        st.phase = "learn";
        st.due = new Date(now.getTime()+10*60*1000).toISOString(); // 10 mins
      } else {
        st.reps = (st.reps||0)+1;
        st.ease = Math.max(1.3, Math.min(3.2, (st.ease||2.5) + (grade==="easy"?+0.15:(grade==="hard"?-0.15:-0.05))));
        if (st.phase==="new"){ st.interval=(grade==="easy")?3:(grade==="hard"?1:2); st.phase="review"; }
        else if (st.phase==="learn"){ st.interval=(grade==="hard")?1:2; st.phase="review"; }
        else {
          const mult=(grade==="easy")?1.5:(grade==="hard"?0.7:1.0);
          st.interval = Math.ceil(Math.max(1, st.interval||1) * st.ease * mult);
          st.interval = Math.max(st.interval, (grade==="easy"?3:(grade==="good"?2:1)));
        }
        st.due = new Date(now.getTime()+st.interval*24*60*60*1000).toISOString();
      }
      if ((st.lapses||0) >= 8) st.suspended = true;

      setState(deckName, card, st);
    }

    function grade(grade){
      if (!filtered.length) return;
      const c = filtered[idx];
      schedule(c.__deck, c, grade);
      render();
      renderCounts();
    }

    function toggleSuspend(){
      if (!filtered.length) return;
      const c = filtered[idx];
      const st = getState(c.__deck, c);
      st.suspended = !st.suspended;
      setState(c.__deck, c, st);
      applyFilters(); // so it disappears from Active if needed
    }

    function addCustomTag(){
      if (!filtered.length) return;
      const c = filtered[idx];
      const st = getState(c.__deck, c);
      const inp = $("addTagInput");
      const tag = (inp.value||"").trim();
      if (!tag) return;
      const arr = Array.isArray(st.extraTags) ? st.extraTags : [];
      if (!arr.includes(tag)) arr.push(tag);
      st.extraTags = arr;
      setState(c.__deck, c, st);
      inp.value = "";
      render();
    }

    // ---------- Stats ----------
    function renderCounts(){
      if (!filtered.length && !allCards.length){ $("counts").textContent = "No cards loaded."; return; }

      const cats = ["Ungraded","Again","Hard","Good","Easy"];
      const overall = Object.fromEntries(cats.map(k=>[k,0]));
      const byChapter = {};

      const scope = ( $("deckSelect").value==="__ALL__" ? allCards : allCards.filter(c=>c.__file===$("deckSelect").value) );
      for (const c of scope){
        const d = userDifficulty(c.__deck, c);
        overall[d] = (overall[d]||0) + 1;
        const chap = c.Chapter || "—";
        if (!byChapter[chap]) byChapter[chap] = Object.fromEntries(cats.map(k=>[k,0]));
        byChapter[chap][d] += 1;
      }

      const pills = cats.map(k => `<span class="pill">${k}: ${overall[k]||0}</span>`).join(" ");
      let chapters = "";
      const chKeys = Object.keys(byChapter);
      if (chKeys.length > 1){
        chapters = '<div class="sep"></div>' + chKeys.map(ch => {
          const row = cats.map(k => `${k[0]}:${byChapter[ch][k]||0}`).join(" · ");
          return `<div class="muted" style="margin:.2rem 0"><strong>${ch}</strong> — ${row}</div>`;
        }).join("");
      }
      $("counts").innerHTML = `Total: ${scope.length}  |  ${pills}` + chapters;
    }

    // ---------- Export / Import ----------
    function exportProgress(){
      const blob = new Blob([JSON.stringify(progress, null, 2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "flashcards-progress.json";
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    async function importProgress(file){
      const txt = await file.text();
      const data = JSON.parse(txt);
      if (!data || typeof data !== "object") throw new Error("Invalid file");
      progress = data;
      saveProgress(progress);
      // rebind progress to allCards
      allCards = allCards.map(c => {
        const p = progress[c.__deck + "::" + hashId(c.Front, c.Back)] || {};
        return { ...c,
          __difficulty: p.difficulty ?? null,
          __suspended: !!p.suspended,
          __extraTags: p.extraTags || [],
          __phase: p.phase || "new",
          __due: p.due || null
        };
      });
      applyFilters();
    }

    // ---------- Init ----------
    async function init(){
      try{
        await loadManifest();
        await loadAll();
        buildDeckSelect();
        applyFilters();
      }catch(e){
        console.error(e);
        $("front").textContent = "Failed to load decks. Ensure /decks/decks.json and the deck files exist.";
      }
    }

    // ---------- Events ----------
    $("deckSelect").addEventListener("change", applyFilters);
    $("refreshBtn").addEventListener("click", async ()=>{
      await loadManifest(); await loadAll(); buildDeckSelect(); applyFilters();
    });
    $("searchBox").addEventListener("input", applyFilters);
    $("tagSearchBox").addEventListener("input", applyFilters);
    $("difficultySelect").addEventListener("change", applyFilters);
    $("statusSelect").addEventListener("change", applyFilters);
    $("exportBtn").addEventListener("click", exportProgress);
    $("importInput").addEventListener("change", (e)=>{ if(e.target.files?.[0]) importProgress(e.target.files[0]); });

    // Keyboard shortcuts
    document.addEventListener("keydown", (e)=>{
      if (e.target.tagName === "INPUT") return;
      if (e.code === "ArrowRight") { nextCard(); e.preventDefault(); }
      else if (e.code === "ArrowLeft") { prevCard(); e.preventDefault(); }
      else if (e.code === "Space") { flipCard(); e.preventDefault(); }
      else if (e.key === "1") grade("again");
      else if (e.key === "2") grade("hard");
      else if (e.key === "3") grade("good");
      else if (e.key === "4") grade("easy");
      else if (e.key.toLowerCase() === "s") toggleSuspend();
    });

    init();
  </script>
</body>
</html>
