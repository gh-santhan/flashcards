<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flashcards ‚Äì SRS</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --muted:#94a3b8; --accent:#22d3ee; --b:#334155; }
    *{box-sizing:border-box}
    body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:linear-gradient(135deg,#0b1024,var(--bg) 35%,#0b1024 70%); color:var(--text); min-height:100vh; display:flex; flex-direction:column}
    header, footer{padding:.75rem 1rem; display:flex; gap:.6rem; align-items:center; flex-wrap:wrap}
    header h1{font-size:1.05rem; margin:0}
    .muted{color:var(--muted)}
    main{flex:1; display:flex; align-items:center; justify-content:center; padding:1rem}
    .container{width:100%; max-width:1100px; display:grid; gap:1rem; grid-template-columns:1fr}
    @media(min-width:980px){ .container{grid-template-columns:2fr 1.1fr} }
    .card{background:radial-gradient(1200px 600px at 10% 0%, #0b1224, var(--panel) 40%); border:1px solid var(--b); border-radius:1rem; padding:1rem; min-height:48vh; display:flex; flex-direction:column; justify-content:space-between; box-shadow:0 10px 30px rgba(0,0,0,.2)}
    .front{font-size:1.15rem; line-height:1.5; white-space:pre-wrap}
    .back{display:none; opacity:.95; white-space:pre-wrap; margin-top:.6rem}
    .btnbar{display:grid; gap:.5rem; grid-template-columns:repeat(5,1fr); margin-top:.75rem}
    button{background:#1f2937; color:var(--text); border:1px solid var(--b); border-radius:.7rem; padding:.7rem .8rem; font-size:1rem; cursor:pointer}
    .again{background:rgba(220,38,38,.12); border-color:#7f1d1d}
    .hard{ background:rgba(234,88,12,.12); border-color:#7c2d12}
    .good{ background:rgba(22,163,74,.12); border-color:#14532d}
    .easy{ background:rgba(37,99,235,.12); border-color:#1e3a8a}
    aside .panel{background:var(--panel); border:1px solid var(--b); border-radius:.8rem; padding:.75rem}
    input, select{background:#0b1224; color:var(--text); border:1px solid var(--b); border-radius:.6rem; padding:.55rem .6rem; width:100%}
    .row{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap}
    .hidden{display:none !important}
    .pill{padding:.25rem .5rem; border:1px solid var(--b); border-radius:.5rem}
    .chip{display:inline-flex; align-items:center; gap:.35rem; padding:.2rem .45rem; border:1px solid var(--b); border-radius:.6rem; margin:.15rem .25rem .15rem 0; font-size:.9rem}
    .chip button{padding:.2rem .35rem; border-radius:.4rem}
    .section-title{margin:.2rem 0 .6rem}
    mark{background:rgba(34,211,238,.25)}
    /* NEW: sidebar toggle + modal lock */
    body.sidebar-hidden aside{ display:none; }
    @media(min-width:980px){ body.sidebar-hidden .container{ grid-template-columns:1fr; } }
    body.modal-open { overflow:hidden; }
    /* Search hit styling */
    #searchResults .hit{border:1px solid var(--b); border-radius:.7rem; padding:.6rem; margin:.35rem 0; background:#0b1224}
    #searchResults .hit h4{margin:.1rem 0 .25rem; font-size:1rem}
    #searchResults .hit p{margin:.15rem 0; white-space:pre-wrap}
    #searchResults .hit .muted{font-size:.9rem}
  </style>
</head>
<body>
  <header>
    <h1>Flashcards ‚Äì SRS</h1>
    <span id="deckName" class="muted">Deck: loading‚Ä¶</span>
    <span class="pill" id="duePill">Due: 0</span>
    <span class="pill" id="posPill">Card 0 / 0</span>
    <span id="gradePill" class="pill">A 0 ¬∑ H 0 ¬∑ G 0 ¬∑ E 0</span>
    <button id="searchBtn" title="Search all decks (/)">Search (/)</button>
    <!-- NEW: sidebar toggle -->
    <button id="toggleSidebarBtn" title="Show/Hide sidebar">‚ò∞ Menu</button>
  </header>

  <main>
    <div class="container">
      <section class="card">
        <div>
          <div class="row muted" id="meta"></div>
          <div class="front" id="front">Loading‚Ä¶</div>
          <div class="back" id="back"></div>
          <div id="tagsRow" class="row" style="margin-top:.6rem"></div>
          <div class="row" style="gap:.4rem; margin-top:.4rem">
            <input id="newTagInput" placeholder="Add tag (Enter)" />
            <button id="addTagBtn">Add tag</button>
            <button id="suspendBtn" title="Hide this card on this device">Suspend</button>
            <button id="unsuspendBtn" class="hidden" title="Show again on this device">Unsuspend</button>
          </div>
        </div>

        <div class="btnbar">
          <button id="revealBtn">Show Answer (Space)</button>
          <button id="prevBtn">‚üµ Prev</button>
          <button id="nextBtn">Next ‚ü∂</button>
          <button id="restartBtn">Restart</button>
        </div>

        <div id="gradeBar" class="btnbar hidden">
          <button class="again" id="againBtn">Again (1)</button>
          <button class="hard"  id="hardBtn">Hard (2)</button>
          <button class="good"  id="goodBtn">Good (3)</button>
          <button class="easy"  id="easyBtn">Easy (4)</button>
          <button id="undoBtn" title="Undo last grade">Undo (U)</button>
        </div>
      </section>

      <aside>
        <div class="panel">
          <h3 class="section-title">Decks</h3>
          <div class="row" style="gap:.5rem">
            <button id="uploadDeckBtn">Upload Deck (JSON)</button>
            <button id="downloadDeckBtn">Download Current</button>
          </div>
          <div style="margin-top:.6rem">
            <label class="muted" for="deckSelect">Switch deck</label>
            <select id="deckSelect"></select>
          </div>
          <input id="fileInput" type="file" accept=".json,application/json" class="hidden">
        </div>

        <div class="panel">
          <h3 class="section-title">Filters</h3>
          <label class="row"><input type="checkbox" id="globalTagsMode"> <span class="muted">Global tags view (all public decks)</span></label>
          <div class="row" style="width:100%">
            <label class="muted" style="min-width:90px">Status</label>
            <select id="statusSelect">
              <option value="due">Due only</option>
              <option value="all">All</option>
              <option value="new">New</option>
              <option value="learn">Learn</option>
              <option value="review">Review</option>
              <option value="suspended">Suspended</option>
            </select>
          </div>
          <div class="row" style="width:100%">
            <label class="muted" style="min-width:90px">Tags</label>
            <input id="tagFilterInput" placeholder="e.g. ACLM-Core, Vignette" />
          </div>
          <div class="row" style="width:100%">
            <label class="muted" style="min-width:90px">Grade</label>
            <select id="gradeSelect">
              <option value="all">All</option>
              <option value="again">Again</option>
              <option value="hard">Hard</option>
              <option value="good">Good</option>
              <option value="easy">Easy</option>
            </select>
          </div>
        </div>

        <div class="panel">
          <h3 class="section-title">Backups & Sync</h3>
          <div class="row" style="gap:.5rem">
            <button id="exportBtn">Export Progress</button>
            <button id="importBtn">Import Progress</button>
            <input id="importInput" type="file" accept=".json" class="hidden">
          </div>
          <div class="row" style="gap:.5rem; margin-top:.5rem">
            <button id="backupNowBtn">Create Backup Now</button>
            <select id="backupSelect" style="flex:1; min-width:220px"></select>
            <button id="restoreBtn">Restore</button>
            <button id="deleteBackupBtn" title="Delete selected backup">üóë</button>
          </div>
          <p class="muted" style="margin:.5rem 0 0">Auto-backup runs every ~6 hours and keeps the 10 latest snapshots. A safety backup is taken when the app is closed.</p>
        </div>
      </aside>
    </div>
  </main>

  <footer class="row" style="justify-content:space-between">
    <span class="muted">Space: Reveal/Hide ¬∑ ‚Üê/‚Üí: Prev/Next ¬∑ 1‚Äì4: Grade ¬∑ /: Search ¬∑ U: Undo</span>
    <a href="decks.json" class="muted" target="_blank" rel="noopener">Open decks.json</a>
  </footer>

  <!-- Global Search modal (darker backdrop) -->
  <div id="searchModal" class="hidden" role="dialog" aria-modal="true" aria-label="Global Search"
       style="position:fixed; inset:0; background:rgba(0,0,0,.72); display:flex; align-items:center; justify-content:center; z-index:50">
    <div class="panel" style="width:min(950px,96vw); max-height:80vh; overflow:auto">
      <div class="row" style="justify-content:space-between; align-items:center">
        <h3 class="section-title" style="margin:.2rem 0">Global Search</h3>
        <button id="closeSearchBtn" aria-label="Close search">‚úï</button>
      </div>
      <div class="row" style="gap:.5rem; margin:.25rem 0 .5rem">
        <input id="searchInput" placeholder="Type keywords‚Ä¶ use #tag for tags (e.g., diabetes #Vignette)" />
        <button id="runSearchBtn">Search</button>
      </div>
      <div class="muted" style="margin:.25rem 0 .5rem">Searches: Front, Back, Tags, Section, Chapter (all decks)</div>
      <div id="searchResults"></div>
    </div>
  </div>

  <script>
    const APP_NS = "flashcards.srs.v3";
    const STATE_PREFIX = APP_NS + ":card:";         // per-card schedule state
    const TAGS_PREFIX  = APP_NS + ":tags:";         // per-card tags overlay
    const MANIFEST_URL = "decks.json";
    const BACKUP_NS = APP_NS + ":backup:";          // rolling snapshots
    const MAX_BACKUPS = 10;

    // App settings (default: exam OFF, auto-advance ON)
    const SETTINGS_KEY = APP_NS + ":settings";
    const settings = (()=>{ 
      try { 
        return JSON.parse(localStorage.getItem(SETTINGS_KEY)) || { exam:false, auto:true }; 
      } catch { 
        return { exam:false, auto:true }; 
      } 
    })();
    function saveSettings(){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }

    let deck = { name:"Demo", cards:[] };
    let order = [];          // visible indices (or virtual list in global mode)
    let idx = 0;
    let publicManifest = { decks: [] };
    const $ = id => document.getElementById(id);

    // Search-results browse mode
    const searchMode = { active:false, list:[], pos:0 };

    // ---------- Global Search helpers ----------
    const deckCache = new Map();
    async function getDeckJSON(file){
      if(deckCache.has(file)) return deckCache.get(file);
      const res = await fetch(file, {cache:"no-store"});
      if(!res.ok) throw new Error("Failed to fetch " + file);
      const json = await res.json();
      deckCache.set(file, json);
      return json;
    }
    function escapeHTML(s){ return String(s).replace(/[&<>"]/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[m])); }
    function highlight(text, terms){
      let safe = escapeHTML(text);
      terms.forEach(t=>{
        if(!t) return;
        const rx = new RegExp("(" + t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&") + ")", "ig");
        safe = safe.replace(rx, "<mark>$1</mark>");
      });
      return safe;
    }
    function parseSearchQuery(q){
      const parts = q.trim().split(/\s+/).filter(Boolean);
      const tags = parts.filter(p=>p.startsWith("#")).map(p=>p.slice(1).toLowerCase());
      const terms = parts.filter(p=>!p.startsWith("#"));
      return {terms, tags};
    }

    // ---------- IDs, State, Tags ----------
    function uidFor(card){
      const s = (card.Front||"") + "::" + (card.Back||"");
      let h = 0; for (let i=0;i<s.length;i++){ h = ((h<<5)-h) + s.charCodeAt(i); h|=0; }
      return String(h);
    }
    function stKey(deckName, uid){ return STATE_PREFIX + deckName + ":" + uid; }
    function loadState(deckName, uid){ try{ const raw = localStorage.getItem(stKey(deckName, uid)); return raw ? JSON.parse(raw) : null; } catch { return null; } }
    function saveState(deckName, uid, st){ localStorage.setItem(stKey(deckName, uid), JSON.stringify(st)); }

    function tagKey(deckName, uid){ return TAGS_PREFIX + deckName + ":" + uid; }
    function loadTags(deckName, uid){ try{ const raw = localStorage.getItem(tagKey(deckName, uid)); return raw ? JSON.parse(raw) : []; } catch { return []; } }
    function saveTags(deckName, uid, tags){ localStorage.setItem(tagKey(deckName, uid), JSON.stringify(tags)); }

    // ---- Undo helpers ----
    const UNDO_PREFIX = APP_NS + ":undo:";
    function undoKey(d,u){ return UNDO_PREFIX + d + ":" + u; }
    function saveUndo(d,u,st){ localStorage.setItem(undoKey(d,u), JSON.stringify(st)); }
    function loadUndo(d,u){ try { return JSON.parse(localStorage.getItem(undoKey(d,u))) } catch { return null } }

    // ---------- Scheduler ----------
    function isDue(deckName, card){
      const st = loadState(deckName, uidFor(card));
      if(!st) return true;
      if(st.suspended) return false;
      if(!st.due) return true;
      return new Date(st.due) <= new Date();
    }
    function schedule(deckName, card, grade){
      const uid = uidFor(card);
      // capture previous state for undo
      const prev = loadState(deckName, uid);
      if(prev) saveUndo(deckName, uid, prev);

      let st = loadState(deckName, uid) || { interval:0, ease:2.5, reps:0, lapses:0, phase:"new", suspended:false };
      const now = new Date();
      if(grade === "again"){
        st.lapses += 1; st.reps = Math.max(0, st.reps - 1); st.interval = 0; st.phase = "learn";
        st.due = new Date(now.getTime() + 10*60*1000).toISOString();
      } else {
        st.reps += 1; st.ease = st.ease || 2.5;
        if(grade === "hard") st.ease = Math.max(1.3, st.ease - 0.15);
        if(grade === "good") st.ease = Math.max(1.3, st.ease - 0.05);
        if(grade === "easy") st.ease = Math.min(3.2, st.ease + 0.15);
        if(st.phase === "new"){ st.interval = (grade==="easy")?3:(grade==="hard"?1:2); st.phase="review"; }
        else if(st.phase === "learn"){ st.interval = (grade==="hard")?1:2; st.phase="review"; }
        else {
          const mult = (grade==="easy")?1.5:(grade==="hard"?0.7:1.0);
          st.interval = Math.ceil(Math.max(1, st.interval) * st.ease * mult);
          st.interval = Math.max(st.interval, (grade==="easy"?3:(grade==="good"?2:1)));
        }
        st.due = new Date(now.getTime() + st.interval*24*60*60*1000).toISOString();
      }

      // Leech handling (suspend at threshold and tag)
      const REVIEW_SETTINGS = APP_NS + ":review";
      const review = (()=>{ try{return JSON.parse(localStorage.getItem(REVIEW_SETTINGS))||{leech:8,tag:true}}catch{return{leech:8,tag:true}}})();
      if(st.lapses >= review.leech){
        st.suspended = true;
        if(review.tag){ const t = loadTags(deckName, uid); if(!t.includes("Leech")){ t.push("Leech"); saveTags(deckName, uid, t); } }
      }

      // Track last grade
      st.lastGrade = grade;
      st.lastGradedAt = Date.now();

      saveState(deckName, uid, st);
    }

    // ---------- Build order (filters, tags, global) ----------
    function cardPhase(deckName, card){
      const st = loadState(deckName, uidFor(card));
      if(!st) return "new";
      if(st.suspended) return "suspended";
      return st.phase || "review";
    }
    function parseTagFilter(){
      const raw = $("tagFilterInput").value.trim();
      if(!raw) return [];
      return raw.split(/[,\s]+/).map(t=>t.trim().toLowerCase()).filter(Boolean);
    }
    function hasAllTags(deckName, card){
      const need = parseTagFilter(); if(need.length===0) return true;
      const uid = uidFor(card);
      const own = (card.Tag ? [String(card.Tag)] : []).concat(card.Tags || []);
      const overlay = loadTags(deckName, uid);
      const have = new Set(own.concat(overlay).map(t=>String(t).toLowerCase()));
      return need.every(t => have.has(t));
    }
    function matchesGradeFilter(deckName, card){
      const val = $("gradeSelect")?.value || "all";
      if (val === "all") return true;
      const st = loadState(deckName, uidFor(card)) || {};
      return st.lastGrade === val;
    }

    function buildOrderCurrentDeck(){
      const status = $("statusSelect").value;  // due, all, new, learn, review, suspended
      const arr = [];
      for(let i=0;i<(deck.cards||[]).length;i++){
        const c = deck.cards[i];
        if(!hasAllTags(deck.name, c)) continue;
        if(!matchesGradeFilter(deck.name, c)) continue;
        const phase = cardPhase(deck.name, c);
        if(status === "due"){ if(!isDue(deck.name,c)) continue; }
        else if(status !== "all"){ if(phase !== status) continue; }
        arr.push(i);
      }
      order = arr;
      if(idx >= order.length) idx = Math.max(0, order.length-1);
    }

    let globalList = [];
    async function buildGlobalList(){
      const status = $("statusSelect").value;
      const list = [];
      for(const d of publicManifest.decks){
        try{
          const res = await fetch(d.file, {cache:"no-store"});
          if(!res.ok) continue;
          const obj = await res.json();
          const dn = obj.name || d.name || d.file;
          (obj.cards||[]).forEach(card=>{
            if(!hasAllTags(dn, card)) return;
            if(!matchesGradeFilter(dn, card)) return;
            const ph = cardPhase(dn, card);
            if(status === "due"){ if(!isDue(dn, card)) return; }
            else if(status !== "all"){ if(ph !== status) return; }
            list.push({ deckName: dn, card });
          });
        }catch{}
      }
      globalList = list;
      order = list.map((_,i)=>i);
      if(idx >= order.length) idx = Math.max(0, order.length-1);
    }

    function updateHeader(){
      $("deckName").textContent = ($("globalTagsMode").checked)
        ? "Global tags view"
        : ("Deck: " + (deck.name || "Deck"));
      const total = order.length;
      $("posPill").textContent  = `Card ${ total ? (idx+1) : 0 } / ${ total }`;

      // Due count
      if($("globalTagsMode").checked){
        let dueCount = 0;
        globalList.forEach(({deckName,card})=>{ if(isDue(deckName,card)) dueCount++; });
        $("duePill").textContent = `Due: ${dueCount}`;
      } else {
        const dueCount = (deck.cards||[]).filter(c => isDue(deck.name, c)).length;
        $("duePill").textContent = `Due: ${dueCount}`;
      }

      // Grade counts across the WHOLE CURRENT DECK (ignores filters)
      (()=>{
        const all = deck.cards || [];
        const gc = {again:0, hard:0, good:0, easy:0};
        all.forEach(c=>{
          const st = loadState(deck.name, uidFor(c)) || {};
          if (gc[st.lastGrade] !== undefined) gc[st.lastGrade] += 1;
        });
        $("gradePill").textContent = `A ${gc.again} ¬∑ H ${gc.hard} ¬∑ G ${gc.good} ¬∑ E ${gc.easy}`;
      })();
    }

    function currentCardEntry(){
      // When browsing search results, source the card from searchMode.list
      if(searchMode.active){
        if(!searchMode.list.length) return null;
        const {deckName, card} = searchMode.list[searchMode.pos];
        return { deckName, card };
      }
      if(!$("globalTagsMode").checked){
        if(!order.length) return null;
        return { deckName: deck.name, card: deck.cards[order[idx]] };
      } else {
        if(!order.length) return null;
        return globalList[order[idx]] || null;
      }
    }

    function render(){
      updateHeader();
      const entry = currentCardEntry();
      const back = $("back");
      const gradeBar = $("gradeBar");
      const suspendBtn = $("suspendBtn");
      const unsuspendBtn = $("unsuspendBtn");
      const tagsRow = $("tagsRow");

      if(!entry){
        $("front").textContent = "No cards match this view.";
        back.style.display = "none"; $("revealBtn").disabled = true; gradeBar.classList.add("hidden"); $("meta").textContent = "";
        suspendBtn.classList.add("hidden"); unsuspendBtn.classList.add("hidden");
        tagsRow.innerHTML = "";
        return;
      }

      const { deckName, card } = entry;
      $("revealBtn").disabled = false;
      $("front").textContent = card.Front || "";
      $("back").textContent  = card.Back  || "";
      back.style.display = "none";
      gradeBar.classList.add("hidden");

      // meta + suspend/unsuspend
      const st = loadState(deckName, uidFor(card)) || {};
      const phase = st.suspended ? "suspended" : (st.phase || "new");
      $("meta").textContent = `Phase: ${phase}` + (st.due ? ` ¬∑ Due: ${new Date(st.due).toLocaleString()}` : "");

      suspendBtn.classList.toggle("hidden", !!st.suspended);
      unsuspendBtn.classList.toggle("hidden", !st.suspended);

      // tags view (own + overlay) ‚Äî SAFE DOM creation
      const own = (card.Tag ? [String(card.Tag)] : []).concat(card.Tags || []);
      const overlay = loadTags(deckName, uidFor(card));
      const allTags = Array.from(new Set(own.concat(overlay)));
      tagsRow.textContent = "";
      allTags.forEach(t=>{
        const chip = document.createElement("span");
        chip.className="chip";
        const txt = document.createElement("span"); txt.textContent = t;
        const btn = document.createElement("button"); btn.textContent = "√ó"; btn.className="removeTagBtn";
        btn.dataset.tag = t;
        chip.appendChild(txt); chip.appendChild(btn);
        tagsRow.appendChild(chip);
      });

      // hide grade bar until reveal
      gradeBar.classList.add("hidden");
      updateSearchRibbonCount();
    }

    function rebuildAndRender(){
      if($("globalTagsMode").checked){
        buildGlobalList().then(()=>{ updateHeader(); render(); });
      } else {
        buildOrderCurrentDeck(); updateHeader(); render();
      }
    }

    // ---------- Deck loading & manifest ----------
    async function fetchManifest(){
      try{
        const res = await fetch(MANIFEST_URL, {cache:"no-store"});
        if(!res.ok) return { decks: [] };
        const json = await res.json();
        return Array.isArray(json.decks) ? json : { decks: [] };
      }catch{ return { decks: [] }; }
    }
    async function loadDeck(url="cards.json"){
      const res = await fetch(url, { cache:"no-store" });
      deck = await res.json();
      idx = 0; buildOrderCurrentDeck(); render(); pushURLIndex();
    }
    function loadDeckObject(obj){
      deck = obj || {name:"Untitled", cards:[]};
      idx = 0; buildOrderCurrentDeck(); render(); pushURLIndex();
    }

    // Local user decks
    const DECKS_KEY = APP_NS + ":userDecks";
    function getStore(){ try{ return JSON.parse(localStorage.getItem(DECKS_KEY)) || {items:[], last:"__default__"} } catch { return {items:[], last:"__default__"} } }
    function setStore(s){ localStorage.setItem(DECKS_KEY, JSON.stringify(s)); }

    async function refreshDeckSelect(){
      publicManifest = await fetchManifest();
      const local = getStore();
      const sel = $("deckSelect");
      const parts = [];

      parts.push('<optgroup label="Public (GitHub)">');
      const pub = (publicManifest.decks||[]);
      if(pub.length===0) parts.push('<option disabled>(No public decks found)</option>');
      pub.forEach(d => parts.push(`<option value="${encodeURIComponent(d.file)}">${d.name}</option>`));
      parts.push('</optgroup>');

      parts.push('<optgroup label="Local (This device)">');
      const items = (local.items||[]);
      if(items.length===0) parts.push('<option disabled>(No local decks)</option>');
      items.forEach(it => parts.push(`<option value="local:${encodeURIComponent(it.name)}">${it.name}</option>`));
      parts.push('</optgroup>');

      sel.innerHTML = parts.join("");
      const last = local.last || "";
      if (last){
        const localVal = "local:" + encodeURIComponent(last);
        if ([...sel.options].some(o=>o.value===localVal)) sel.value = localVal;
      } else if (pub.length > 0){
        sel.value = encodeURIComponent(pub[0].file);
      }
    }

    // ---------- Actions & UI wiring ----------
    function showAnswer(){
      const back = $("back"); const gradeBar = $("gradeBar");
      if(back.style.display === "block"){ back.style.display = "none"; gradeBar.classList.add("hidden"); }
      else { back.style.display = "block"; gradeBar.classList.remove("hidden"); }
    }
    function pushURLIndex(){
      const params = new URLSearchParams(location.search);
      params.set("i", String(idx));
      history.replaceState(null, "", "?" + params.toString());
    }

    function next(){
      if(searchMode.active){
        if(searchMode.pos < searchMode.list.length-1) searchMode.pos++;
        updateSearchRibbonCount();
        render();
        return;
      }
      if (idx < order.length-1) { idx++; render(); pushURLIndex(); }
    }
    function prev(){
      if(searchMode.active){
        if(searchMode.pos > 0) searchMode.pos--;
        updateSearchRibbonCount();
        render();
        return;
      }
      if (idx > 0) { idx--; render(); pushURLIndex(); }
    }

    function doGrade(g){
      const entry = currentCardEntry(); if(!entry) return;
      schedule(entry.deckName, entry.card, g);
      // safety snapshot every 25 grades
      window._gradesSinceBackup = (window._gradesSinceBackup||0) + 1;
      if(window._gradesSinceBackup % 25 === 0) createBackup();
      if(settings.auto){ next(); rebuildAndRender(); }
      else { rebuildAndRender(); }
    }

    $("revealBtn").onclick = showAnswer;
    $("prevBtn").onclick   = prev;
    $("nextBtn").onclick   = next;
    $("restartBtn").onclick= () => { idx = 0; render(); };

    $("againBtn").onclick = () => doGrade("again");
    $("hardBtn").onclick  = () => doGrade("hard");
    $("goodBtn").onclick  = () => doGrade("good");
    $("easyBtn").onclick  = () => doGrade("easy");

    $("statusSelect").onchange = rebuildAndRender;
    $("tagFilterInput").addEventListener("keyup", (e)=>{ if(e.key==="Enter"){ rebuildAndRender(); }});
    $("tagFilterInput").addEventListener("blur", rebuildAndRender);
    $("globalTagsMode").onchange = rebuildAndRender;

    // Grade filter
    $("gradeSelect").onchange = rebuildAndRender;

    // Sidebar toggle
    $("toggleSidebarBtn").onclick = ()=>{ document.body.classList.toggle("sidebar-hidden"); };

    // Tag editing
    function addTagTo(entry, tag){
      const deckName = entry.deckName, card = entry.card; if(!tag) return;
      const uid = uidFor(card);
      const tags = loadTags(deckName, uid);
      if(!tags.map(s=>s.toLowerCase()).includes(tag.toLowerCase())){
        tags.push(tag);
        saveTags(deckName, uid, tags);
      }
    }
    function removeTagFrom(entry, tag){
      const deckName = entry.deckName, card = entry.card;
      const uid = uidFor(card);
      const tags = loadTags(deckName, uid).filter(t => t.toLowerCase() !== tag.toLowerCase());
      saveTags(deckName, uid, tags);
    }

    $("addTagBtn").onclick = ()=>{
      const entry = currentCardEntry(); if(!entry) return;
      const val = $("newTagInput").value.trim(); if(!val) return;
      val.split(/[,\s]+/).forEach(t=> addTagTo(entry, t.trim()));
      $("newTagInput").value = "";
      render();
    };
    $("newTagInput").addEventListener("keydown",(e)=>{
      if(e.key==="Enter"){ e.preventDefault(); $("addTagBtn").click(); }
    });
    document.addEventListener("click",(e)=>{
      if(e.target && e.target.classList.contains("removeTagBtn")){
        const tag = e.target.dataset.tag;
        const entry = currentCardEntry(); if(!entry) return;
        removeTagFrom(entry, tag);
        render();
      }
    });

    // Suspend / Unsuspend
    $("suspendBtn").onclick = ()=>{
      const entry = currentCardEntry(); if(!entry) return;
      const {deckName, card} = entry;
      const uid = uidFor(card);
      const st = loadState(deckName, uid) || { phase:"new", ease:2.5, interval:0, reps:0, lapses:0 };
      st.suspended = true;
      saveState(deckName, uid, st);
      rebuildAndRender();
    };
    $("unsuspendBtn").onclick = ()=>{
      const entry = currentCardEntry(); if(!entry) return;
      const {deckName, card} = entry;
      const uid = uidFor(card);
      const st = loadState(deckName, uid) || {};
      st.suspended = false;
      saveState(deckName, uid, st);
      rebuildAndRender();
    };

    // Upload / download decks
    function validateDeck(obj){
      const err = [];
      if(!obj || typeof obj!=="object") err.push("Root must be an object.");
      if(!Array.isArray(obj.cards)) err.push("cards[] missing or not an array.");
      else obj.cards.forEach((c,i)=>{
        if(typeof c.Front!=="string") err.push(`cards[${i}].Front must be string`);
        if(typeof c.Back!=="string")  err.push(`cards[${i}].Back must be string`);
      });
      return err;
    }

    $("uploadDeckBtn").onclick = () => $("fileInput").click();
    $("fileInput").onchange = e => {
      const f = e.target.files[0]; if(!f) return;
      const r = new FileReader();
      r.onload = () => {
        try{
          const obj = JSON.parse(r.result);
          const errors = validateDeck(obj);
          if(errors.length){ alert("Deck validation failed:\n" + errors.join("\n")); e.target.value=""; return; }
          const s = getStore();
          let name = obj.name || f.name.replace(/\.json$/i,"");
          const seen = new Set(s.items.map(x=>x.name));
          let k=2, base=name; while(seen.has(name)) name = base + " (" + (k++) + ")";
          s.items.push({name, data:obj}); s.last=name; setStore(s);
          refreshDeckSelect().then(()=>{
            $("deckSelect").value = "local:" + encodeURIComponent(name);
            loadDeckObject(obj);
          });
        }catch{ alert("Invalid JSON deck file."); }
        e.target.value="";
      };
      r.readAsText(f);
    };

    $("deckSelect").onchange = () => {
      $("globalTagsMode").checked = false; // leaving global mode when switching deck
      const val = $("deckSelect").value;
      if (val.startsWith("local:")){
        const name = decodeURIComponent(val.slice("local:".length));
        const it = getStore().items.find(x=>x.name===name);
        if(it){ loadDeckObject(it.data); const s=getStore(); s.last=name; setStore(s); }
      } else {
        loadDeck(decodeURIComponent(val));
        const s=getStore(); s.last=""; setStore(s);
      }
    };
    $("downloadDeckBtn").onclick = () => {
      const blob = new Blob([JSON.stringify(deck,null,2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = (deck.name || "deck") + ".json";
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0);
    };

    // Keyboard shortcuts
    document.addEventListener("keydown",(e)=>{
      if(e.code === "Space"){ e.preventDefault(); showAnswer(); }
      if(e.key === "ArrowRight") next();
      if(e.key === "ArrowLeft")  prev();
      if(e.key === "1") $("againBtn").click();
      if(e.key === "2") $("hardBtn").click();
      if(e.key === "3") $("goodBtn").click();
      if(e.key === "4") $("easyBtn").click();
      if(e.key==="/"){ e.preventDefault(); openSearch(); }
      if(e.key==="?"){ alert("Shortcuts:\nSpace Reveal/Hide\n‚Üê/‚Üí Prev/Next\n1‚Äì4 Grade\n/ Search\nU Undo\n"); }
    });

    // ---------- Backups ----------
    function collectAllProgress(){
      const out = {};
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(k && (k.startsWith(STATE_PREFIX) || k.startsWith(TAGS_PREFIX) || k.startsWith(DECKS_KEY))){
          out[k] = localStorage.getItem(k);
        }
      }
      return out;
    }
    function applyProgressDump(obj){
      const toRemove = [];
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(k && (k.startsWith(STATE_PREFIX) || k.startsWith(TAGS_PREFIX) || k.startsWith(DECKS_KEY))){
          toRemove.push(k);
        }
      }
      toRemove.forEach(k=>localStorage.removeItem(k));
      Object.entries(obj).forEach(([k,v])=>{
        localStorage.setItem(k, v);
      });
    }
    function refreshBackupsDropdown(){
      const sel = $("backupSelect");
      const keys = [];
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(k && k.startsWith(BACKUP_NS)) keys.push(k);
      }
      keys.sort(); // chronological by suffix
      sel.innerHTML = keys.map(k=>`<option value="${k}">${k.slice(BACKUP_NS.length)}</option>`).join("");
    }
    function createBackup(){
      const stamp = new Date().toISOString().replace(/[:.]/g,"-");
      const data = JSON.stringify(collectAllProgress());
      localStorage.setItem(BACKUP_NS + stamp, data);
      // prune
      const keys = [];
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(k && k.startsWith(BACKUP_NS)) keys.push(k);
      }
      keys.sort();
      while(keys.length > MAX_BACKUPS){
        const k = keys.shift();
        localStorage.removeItem(k);
      }
      refreshBackupsDropdown();
    }

    $("exportBtn").onclick = ()=>{
      const blob = new Blob([JSON.stringify(collectAllProgress(), null, 2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "flashcards-progress.json";
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0);
    };
    $("importBtn").onclick = ()=> $("importInput").click();
    $("importInput").onchange = e=>{
      const f = e.target.files[0]; if(!f) return;
      const r = new FileReader();
      r.onload = ()=>{
        try{
          const obj = JSON.parse(r.result);
          applyProgressDump(obj);
          rebuildAndRender();
          alert("Progress imported.");
        }catch{ alert("Invalid progress file."); }
      };
      r.readAsText(f);
      e.target.value = "";
    };
    $("backupNowBtn").onclick = ()=>{ createBackup(); alert("Backup created."); };
    $("restoreBtn").onclick   = ()=>{
      const k = $("backupSelect").value; if(!k){ alert("No backup selected."); return; }
      const raw = localStorage.getItem(k); if(!raw){ alert("Backup not found."); return; }
      try{ const obj = JSON.parse(raw); applyProgressDump(obj); rebuildAndRender(); alert("Backup restored."); }
      catch{ alert("Backup corrupted."); }
    };
    $("deleteBackupBtn").onclick = ()=>{
      const k = $("backupSelect").value; if(!k) return;
      if(!confirm("Delete this backup?")) return;
      localStorage.removeItem(k); refreshBackupsDropdown();
    };

    // Auto-backup timer (6 hours) + safety backups
    setInterval(()=>{ if(!document.hidden) createBackup(); }, 6*60*60*1000);
    document.addEventListener("visibilitychange", ()=>{ if(document.hidden) createBackup(); });
    window.addEventListener("beforeunload", ()=>{ try{ createBackup(); }catch{} });

    // ---------- Global Search UI ----------
    const searchModal = $("searchModal");
    const searchInput  = $("searchInput");
    const searchResults = $("searchResults");

    function openSearch(){ searchModal.classList.remove("hidden"); searchInput.focus(); document.body.classList.add("modal-open"); }
    function closeSearch(){ searchModal.classList.add("hidden"); document.body.classList.remove("modal-open"); }

    $("searchBtn").onclick = openSearch;
    $("closeSearchBtn").onclick = closeSearch;

    let searchTimer = null;
    $("runSearchBtn").onclick = runSearch;
    searchInput.addEventListener("keyup", (e)=>{
      if(e.key==="Enter") runSearch();
      else { clearTimeout(searchTimer); searchTimer = setTimeout(runSearch, 250); }
    });

    function matchesSearchCard(deckName, card, terms, tagFilters){
      const uid = uidFor(card);
      const own = (card.Tag ? [String(card.Tag)] : []).concat(card.Tags || []);
      const overlay = loadTags(deckName, uid);
      const allTags = new Set(own.concat(overlay).map(t=>String(t).toLowerCase()));
      if(tagFilters.length && !tagFilters.every(t => allTags.has(t))) return false;
      const hay = [card.Front||"", card.Back||"", card.Section||"", card.Chapter||""].join(" ").toLowerCase();
      return terms.every(t => hay.includes(t.toLowerCase()));
    }

    async function searchAcrossDecks(query){
      const {terms, tags} = parseSearchQuery(query);
      if(terms.length===0 && tags.length===0) return [];
      const hits = [];

      // Public decks
      for(const d of (publicManifest.decks||[])){
        try{
          const obj = await getDeckJSON(d.file);
          const dn = obj.name || d.name || d.file;
          (obj.cards||[]).forEach((card, i)=>{
            if(!matchesSearchCard(dn, card, terms, tags)) return;
            hits.push({source:"public", file:d.file, deckName:dn, card, index:i});
          });
        }catch{}
      }
      // Local decks
      const local = getStore();
      for(const it of (local.items||[])){
        const dn = it.name;
        (it.data?.cards||[]).forEach((card, i)=>{
          if(!matchesSearchCard(dn, card, terms, tags)) return;
          hits.push({source:"local", deckName:dn, card, index:i});
        });
      }
      return hits;
    }

    // Search results mode helpers
    function enterSearchMode(hits){
      searchMode.active = true;
      searchMode.list = hits.map(h=>({ deckName:h.deckName, card:h.card }));
      searchMode.pos = 0;
      showSearchRibbon(hits.length);
      render();
    }
    function exitSearchMode(){
      searchMode.active = false;
      searchMode.list = [];
      searchMode.pos = 0;
      hideSearchRibbon();
      rebuildAndRender();
    }
    function showSearchRibbon(total){
      if($("searchRibbon")) return;
      const bar = document.createElement("div");
      bar.id = "searchRibbon";
      bar.className = "pill";
      bar.style.cssText = "position:fixed;right:12px;bottom:12px;z-index:55;background:#0b1224;border:1px solid var(--b);";
      bar.innerHTML = `Search results ‚Äî <span id="srCount">1/${total}</span> <button id="exitSearchBtn" style="margin-left:.5rem">Exit</button>`;
      document.body.appendChild(bar);
      $("exitSearchBtn").onclick = exitSearchMode;
    }
    function hideSearchRibbon(){
      const el = $("searchRibbon"); if(el) el.remove();
    }
    function updateSearchRibbonCount(){
      if(!searchMode.active) return;
      const n = searchMode.list.length;
      const i = Math.min(searchMode.pos+1, n);
      const el = $("srCount"); if(el) el.textContent = `${i}/${n}`;
    }

    async function runSearch(){
      const q = searchInput.value.trim();
      searchResults.innerHTML = `<div class="muted">Searching‚Ä¶</div>`;
      try{
        const hits = await searchAcrossDecks(q);
        if(hits.length===0){ searchResults.innerHTML = `<div class="muted">No matches.</div>`; return; }
        const {terms} = parseSearchQuery(q);

        // Header with Browse All
        const header = `
          <div class="row" style="justify-content:space-between; align-items:center; margin:.25rem 0 .5rem">
            <span class="muted">${hits.length} matches</span>
            <button id="browseAllBtn">Browse All</button>
          </div>`;

        const parts = hits.slice(0,500).map((h, idx)=>{
          const front = highlight(h.card.Front||"", terms);
          const back  = highlight((h.card.Back||"").slice(0,240), terms);
          const tags = (h.card.Tags||[]).concat(h.card.Tag?[h.card.Tag]:[]);
          const tagTxt = tags.length ? `<span class="muted">Tags: ${escapeHTML(tags.join(", "))}</span>` : "";
          return `
            <div class="hit">
              <h4>${escapeHTML(h.deckName)} ‚Ä¢ #${h.index+1}</h4>
              <p><strong>Q:</strong> ${front}</p>
              <p class="muted"><strong>A (preview):</strong> ${back}${(h.card.Back||"").length>240?"‚Ä¶":""}</p>
              ${tagTxt}
              <div class="row" style="margin-top:.35rem; gap:.4rem">
                <button class="openHitBtn" data-i="${idx}">Open</button>
              </div>
            </div>`;
        });
        searchResults.innerHTML = header + parts.join("");

        // wire browse all
        const browseBtn = document.getElementById("browseAllBtn");
        if(browseBtn){
          browseBtn.onclick = ()=>{
            enterSearchMode(hits);
            closeSearch(); // enter browse mode in main UI
          };
        }

        // attach open handlers (keep modal open for multi-open)
        [...searchResults.querySelectorAll(".openHitBtn")].forEach(btn=>{
          btn.addEventListener("click", async ()=>{
            const h = hits[Number(btn.dataset.i)];
            await jumpToSearchHit(h);
            // DO NOT close the modal here ‚Äî allows opening multiple hits
          });
        });

      }catch{
        searchResults.innerHTML = `<div class="muted">Search failed. Check console.</div>`;
      }
    }

    async function jumpToSearchHit(h){
      $("statusSelect").value = "all";
      const gradeSel = $("gradeSelect"); if(gradeSel) gradeSel.value = "all";
      $("tagFilterInput").value = "";
      $("globalTagsMode").checked = false;

      if(h.source==="public"){
        $("deckSelect").value = encodeURIComponent(h.file);
        await loadDeck(h.file);
      } else if(h.source==="local"){
        const local = getStore();
        const it = (local.items||[]).find(x=>x.name===h.deckName);
        if(it){
          $("deckSelect").value = "local:" + encodeURIComponent(h.deckName);
          loadDeckObject(it.data);
        }
      } else { return; }

      buildOrderCurrentDeck();
      const targetUID = uidFor(h.card);
      const absoluteIndex = (deck.cards||[]).findIndex(c => uidFor(c)===targetUID);
      const posInOrder = order.indexOf(absoluteIndex);
      if(posInOrder >= 0){ idx = posInOrder; render(); }
      else { idx = 0; render(); }
    }

    // Undo button + hotkey
    $("undoBtn").onclick = ()=>{
      const e = currentCardEntry(); if(!e) return;
      const uid = uidFor(e.card);
      const snap = loadUndo(e.deckName, uid); if(!snap) return;
      saveState(e.deckName, uid, snap); 
      rebuildAndRender();
    };
    document.addEventListener("keydown",(ev)=>{ if(ev.key.toLowerCase()==="u") $("undoBtn").click(); });

    // ---------- Boot ----------
    document.addEventListener("DOMContentLoaded", async ()=>{
      await refreshDeckSelect();
      // URL override ?deck=path.json
      const params = new URLSearchParams(location.search);
      const urlDeck = params.get("deck");
      if (urlDeck){ await loadDeck(urlDeck); }
      else {
        const val = $("deckSelect").value;
        if (val && !val.startsWith("local:")) await loadDeck(decodeURIComponent(val));
        else await loadDeck("cards.json");
      }
      refreshBackupsDropdown();
    });

    // Register SW (offline)
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", ()=> navigator.serviceWorker.register("sw.js").catch(()=>{}));
    }
  </script>
</body>
</html>
