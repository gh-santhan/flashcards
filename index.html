<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flashcards – SRS</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --muted:#94a3b8; --accent:#22d3ee; --b:#334155; }
    *{box-sizing:border-box}
    body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:linear-gradient(135deg,#0b1024,var(--bg) 35%,#0b1024 70%); color:var(--text); min-height:100vh; display:flex; flex-direction:column}
    header, footer{padding:.75rem 1rem; display:flex; gap:.6rem; align-items:center; flex-wrap:wrap}
    header h1{font-size:1.05rem; margin:0}
    .muted{color:var(--muted)}
    main{flex:1; display:flex; align-items:center; justify-content:center; padding:1rem}
    .container{width:100%; max-width:1000px; display:grid; gap:1rem; grid-template-columns:1fr}
    @media(min-width:900px){ .container{grid-template-columns:2fr 1fr} }
    .card{background:radial-gradient(1200px 600px at 10% 0%, #0b1224, var(--panel) 40%); border:1px solid var(--b); border-radius:1rem; padding:1rem; min-height:46vh; display:flex; flex-direction:column; justify-content:space-between; box-shadow:0 10px 30px rgba(0,0,0,.2)}
    .front{font-size:1.15rem; line-height:1.5; white-space:pre-wrap}
    .back{display:none; opacity:.95; white-space:pre-wrap; margin-top:.6rem}
    .btnbar{display:grid; gap:.5rem; grid-template-columns:repeat(4,1fr); margin-top:.75rem}
    button{background:#1f2937; color:var(--text); border:1px solid var(--b); border-radius:.7rem; padding:.7rem .8rem; font-size:1rem; cursor:pointer}
    .again{background:rgba(220,38,38,.12); border-color:#7f1d1d}
    .hard{ background:rgba(234,88,12,.12); border-color:#7c2d12}
    .good{ background:rgba(22,163,74,.12); border-color:#14532d}
    .easy{ background:rgba(37,99,235,.12); border-color:#1e3a8a}
    aside .panel{background:var(--panel); border:1px solid var(--b); border-radius:.8rem; padding:.75rem}
    input, select{background:#0b1224; color:var(--text); border:1px solid var(--b); border-radius:.6rem; padding:.55rem .6rem; width:100%}
    .row{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap}
    .hidden{display:none !important}
    .pill{padding:.25rem .5rem; border:1px solid var(--b); border-radius:.5rem}
  </style>
</head>
<body>
  <header>
    <h1>Flashcards – SRS</h1>
    <span id="deckName" class="muted">Deck: loading…</span>
    <span class="pill" id="duePill">Due: 0</span>
    <span class="pill" id="posPill">Card 0 / 0</span>
  </header>

  <main>
    <div class="container">
      <section class="card">
        <div>
          <div class="row muted" id="meta"></div>
          <div class="front" id="front">Loading…</div>
          <div class="back" id="back"></div>
        </div>

        <div class="btnbar">
          <button id="revealBtn">Show Answer (Space)</button>
          <button id="prevBtn">⟵ Prev</button>
          <button id="nextBtn">Next ⟶</button>
          <button id="restartBtn">Restart</button>
        </div>

        <div id="gradeBar" class="btnbar hidden">
          <button class="again" id="againBtn">Again (1)</button>
          <button class="hard"  id="hardBtn">Hard (2)</button>
          <button class="good"  id="goodBtn">Good (3)</button>
          <button class="easy"  id="easyBtn">Easy (4)</button>
        </div>
      </section>

      <aside>
        <div class="panel">
          <h3 style="margin:.2rem 0 .6rem">Deck</h3>
          <div class="row" style="gap:.5rem">
            <button id="uploadDeckBtn">Upload Deck (JSON)</button>
            <button id="downloadDeckBtn">Download Current</button>
          </div>
          <div style="margin-top:.6rem">
            <label class="muted" for="deckSelect">Switch deck</label>
            <select id="deckSelect">
              <option value="__default__">Default (cards.json)</option>
            </select>
          </div>
          <input id="fileInput" type="file" accept=".json,application/json" class="hidden">
        </div>

        <div class="panel">
          <h3 style="margin:.2rem 0 .6rem">Filters</h3>
          <label class="row"><input type="checkbox" id="dueOnly" checked> <span class="muted">Show due cards only</span></label>
        </div>
      </aside>
    </div>
  </main>

  <footer class="row" style="justify-content:space-between">
    <span class="muted">Tip: Space = Reveal/Hide, Arrow keys = Prev/Next, 1–4 = Grade.</span>
    <a href="cards.json" class="muted" target="_blank" rel="noopener">Open cards.json</a>
  </footer>

  <script>
    const APP_NS = "flashcards.srs.v1";
    const STATE_PREFIX = APP_NS + ":card:"; // STATE_PREFIX + deckName + ":" + uid

    let deck = { name:"Demo", cards:[] };
    let order = [];   // indices of cards currently visible (filtered)
    let idx = 0;      // pointer into 'order'

    const qs = id => document.getElementById(id);

    // ---------- Identifiers & state ----------
    function uidFor(card){
      const s = (card.Front||"") + "::" + (card.Back||"");
      let h = 0; for (let i=0;i<s.length;i++){ h = ((h<<5)-h) + s.charCodeAt(i); h|=0; }
      return String(h);
    }
    function stKey(deckName, uid){ return STATE_PREFIX + deckName + ":" + uid; }
    function loadState(deckName, uid){
      try{ const raw = localStorage.getItem(stKey(deckName, uid)); return raw ? JSON.parse(raw) : null; }
      catch{ return null; }
    }
    function saveState(deckName, uid, st){ localStorage.setItem(stKey(deckName, uid), JSON.stringify(st)); }

    // ---------- Scheduler (simple SM-2 like) ----------
    function isDue(deckName, card){
      const st = loadState(deckName, uidFor(card));
      if(!st) return true;
      if(st.suspended) return false;
      if(!st.due) return true;
      return new Date(st.due) <= new Date();
    }

    function schedule(deckName, card, grade){
      const uid = uidFor(card);
      let st = loadState(deckName, uid) || { interval:0, ease:2.5, reps:0, lapses:0, phase:"new", suspended:false };
      const now = new Date();

      if(grade === "again"){
        st.lapses += 1;
        st.reps = Math.max(0, st.reps - 1);
        st.interval = 0;
        st.phase = "learn";
        st.due = new Date(now.getTime() + 10*60*1000).toISOString(); // 10 mins
      } else {
        st.reps += 1;
        st.ease = st.ease || 2.5;
        if(grade === "hard") st.ease = Math.max(1.3, st.ease - 0.15);
        if(grade === "good") st.ease = Math.max(1.3, st.ease - 0.05);
        if(grade === "easy") st.ease = Math.min(3.2, st.ease + 0.15);

        if(st.phase === "new"){
          st.interval = (grade === "easy") ? 3 : (grade === "hard" ? 1 : 2);
          st.phase = "review";
        } else if(st.phase === "learn"){
          st.interval = (grade === "hard") ? 1 : 2;
          st.phase = "review";
        } else {
          const mult = (grade === "easy") ? 1.5 : (grade === "hard" ? 0.7 : 1.0);
          st.interval = Math.ceil(Math.max(1, st.interval) * st.ease * mult);
          st.interval = Math.max(st.interval, (grade === "easy" ? 3 : (grade === "good" ? 2 : 1)));
        }

        st.due = new Date(now.getTime() + st.interval*24*60*60*1000).toISOString();
      }

      if(st.lapses >= 8){ st.suspended = true; } // auto-suspend leeches
      saveState(deckName, uid, st);
    }

    // ---------- View building ----------
    function buildOrder(){
      const onlyDue = qs("dueOnly").checked;
      const arr = [];
      for(let i=0;i<(deck.cards||[]).length;i++){
        const c = deck.cards[i];
        if(onlyDue && !isDue(deck.name, c)) continue;
        arr.push(i);
      }
      order = arr;
      if(idx >= order.length) idx = Math.max(0, order.length-1);
      updateHeader();
    }

    function updateHeader(){
      qs("deckName").textContent = "Deck: " + (deck.name || "Deck");
      qs("posPill").textContent  = `Card ${ order.length ? (idx+1) : 0 } / ${ order.length }`;
      const dueCount = (deck.cards||[]).filter(c => isDue(deck.name, c)).length;
      qs("duePill").textContent  = `Due: ${dueCount}`;
    }

    function currentCard(){
      if(!order.length) return null;
      return deck.cards[order[idx]];
    }

    function render(){
      updateHeader();
      const c = currentCard();
      const back = qs("back");
      const revealBtn = qs("revealBtn");
      const gradeBar = qs("gradeBar");

      if(!c){
        qs("front").textContent = "No cards match this view.";
        back.style.display = "none";
        revealBtn.disabled = true;
        gradeBar.classList.add("hidden");
        qs("meta").textContent = "";
        return;
      }

      revealBtn.disabled = false;
      qs("front").textContent = c.Front || "";
      qs("back").textContent  = c.Back  || "";
      back.style.display = "none";
      qs("meta").textContent = c.Tag ? ("Tag: " + c.Tag) : "";
      gradeBar.classList.add("hidden");
    }

    // ---------- Deck loading / upload ----------
    async function loadDeck(url="cards.json"){
      const res = await fetch(url, { cache:"no-store" });
      deck = await res.json();
      idx = 0; buildOrder(); render();
    }
    function loadDeckObject(obj){
      deck = obj || {name:"Untitled", cards:[]};
      idx = 0; buildOrder(); render();
    }

    // Multi-deck local store
    const DECKS_KEY = APP_NS + ":userDecks";
    function getStore(){ try{ return JSON.parse(localStorage.getItem(DECKS_KEY)) || {items:[], last:"__default__"} } catch { return {items:[], last:"__default__"} } }
    function setStore(s){ localStorage.setItem(DECKS_KEY, JSON.stringify(s)); }
    function refreshDeckSelect(){
      const s = getStore();
      const sel = qs("deckSelect");
      const current = sel.value || s.last || "__default__";
      sel.innerHTML = '<option value="__default__">Default (cards.json)</option>' +
        s.items.map(it => `<option value="${encodeURIComponent(it.name)}">${it.name}</option>`).join("");
      sel.value = current;
    }

    qs("uploadDeckBtn").onclick = () => qs("fileInput").click();
    qs("fileInput").onchange = e => {
      const f = e.target.files[0]; if(!f) return;
      const r = new FileReader();
      r.onload = () => {
        try{
          const obj = JSON.parse(r.result);
          const s = getStore();
          let name = obj.name || f.name.replace(/\.json$/i,"");
          const seen = new Set(s.items.map(x=>x.name));
          let k=2, base=name; while(seen.has(name)) name = base + " (" + (k++) + ")";
          s.items.push({name, data:obj}); s.last=name; setStore(s);
          refreshDeckSelect(); qs("deckSelect").value = encodeURIComponent(name);
          loadDeckObject(obj);
        }catch{ alert("Invalid JSON deck file."); }
        e.target.value="";
      };
      r.readAsText(f);
    };

    qs("deckSelect").onchange = () => {
      const val = qs("deckSelect").value;
      if (val === "__default__"){
        const s = getStore(); s.last="__default__"; setStore(s); loadDeck("cards.json");
      } else {
        const name = decodeURIComponent(val);
        const it = getStore().items.find(x=>x.name===name);
        if(it){ loadDeckObject(it.data); const s=getStore(); s.last=name; setStore(s); }
      }
    };

    qs("downloadDeckBtn").onclick = () => {
      const blob = new Blob([JSON.stringify(deck,null,2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = (deck.name || "deck") + ".json";
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0);
    };

    // ---------- Actions ----------
    function showAnswer(){
      const back = qs("back");
      const gradeBar = qs("gradeBar");
      if(back.style.display === "block"){
        back.style.display = "none";
        gradeBar.classList.add("hidden");
      }else{
        back.style.display = "block";
        gradeBar.classList.remove("hidden");
      }
    }
    function next(){ if (idx < order.length-1) { idx++; render(); } }
    function prev(){ if (idx > 0) { idx--; render(); } }

    function doGrade(g){
      const c = currentCard(); if(!c) return;
      schedule(deck.name, c, g);
      buildOrder(); // rebuild due list after scheduling
      if(order.length === 0){ render(); return; }
      if (idx >= order.length) idx = Math.max(0, order.length-1);
      render();
      // auto-advance if there are remaining cards and answer is still showing
    }

    // Buttons
    qs("revealBtn").onclick = showAnswer;
    qs("prevBtn").onclick   = prev;
    qs("nextBtn").onclick   = next;
    qs("restartBtn").onclick= () => { idx = 0; render(); };

    qs("againBtn").onclick = () => doGrade("again");
    qs("hardBtn").onclick  = () => doGrade("hard");
    qs("goodBtn").onclick  = () => doGrade("good");
    qs("easyBtn").onclick  = () => doGrade("easy");

    // Filters
    qs("dueOnly").onchange = () => { buildOrder(); render(); };

    // Keyboard shortcuts
    document.addEventListener("keydown",(e)=>{
      if(e.code === "Space"){ e.preventDefault(); showAnswer(); }
      if(e.key === "ArrowRight") next();
      if(e.key === "ArrowLeft")  prev();
      if(e.key === "1") qs("againBtn").click();
      if(e.key === "2") qs("hardBtn").click();
      if(e.key === "3") qs("goodBtn").click();
      if(e.key === "4") qs("easyBtn").click();
    });

    // ---------- Boot ----------
    document.addEventListener("DOMContentLoaded", ()=>{
      refreshDeckSelect();
      const store = getStore();
      if(store.last && store.last !== "__default__"){
        const it = store.items.find(x=>x.name===store.last);
        if(it){ qs("deckSelect").value = encodeURIComponent(store.last); loadDeckObject(it.data); return; }
      }
      loadDeck(); // default
    });
  </script>
</body>
</html>
