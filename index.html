<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flashcards – SRS</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --muted:#94a3b8; --accent:#22d3ee; --b:#334155; }
    *{box-sizing:border-box}
    body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:linear-gradient(135deg,#0b1024,var(--bg) 35%,#0b1024 70%); color:var(--text); min-height:100vh; display:flex; flex-direction:column}
    header, footer{padding:.75rem 1rem; display:flex; gap:.6rem; align-items:center; flex-wrap:wrap}
    header h1{font-size:1.05rem; margin:0}
    .muted{color:var(--muted)}
    main{flex:1; display:flex; align-items:center; justify-content:center; padding:1rem}
    .container{width:100%; max-width:1000px; display:grid; gap:1rem; grid-template-columns:1fr}
    @media(min-width:900px){ .container{grid-template-columns:2fr 1fr} }
    .card{background:radial-gradient(1200px 600px at 10% 0%, #0b1224, var(--panel) 40%); border:1px solid var(--b); border-radius:1rem; padding:1rem; min-height:46vh; display:flex; flex-direction:column; justify-content:space-between; box-shadow:0 10px 30px rgba(0,0,0,.2)}
    .front{font-size:1.15rem; line-height:1.5; white-space:pre-wrap}
    .back{display:none; opacity:.95; white-space:pre-wrap; margin-top:.6rem}
    .btnbar{display:grid; gap:.5rem; grid-template-columns:repeat(4,1fr); margin-top:.75rem}
    button{background:#1f2937; color:var(--text); border:1px solid var(--b); border-radius:.7rem; padding:.7rem .8rem; font-size:1rem; cursor:pointer}
    .again{background:rgba(220,38,38,.12); border-color:#7f1d1d}
    .hard{ background:rgba(234,88,12,.12); border-color:#7c2d12}
    .good{ background:rgba(22,163,74,.12); border-color:#14532d}
    .easy{ background:rgba(37,99,235,.12); border-color:#1e3a8a}
    aside .panel{background:var(--panel); border:1px solid var(--b); border-radius:.8rem; padding:.75rem}
    input, select{background:#0b1224; color:var(--text); border:1px solid var(--b); border-radius:.6rem; padding:.55rem .6rem; width:100%}
    .row{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap}
    .hidden{display:none !important}
    .pill{padding:.25rem .5rem; border:1px solid var(--b); border-radius:.5rem}
  </style>
</head>
<body>
  <header>
    <h1>Flashcards – SRS</h1>
    <span id="deckName" class="muted">Deck: loading…</span>
    <span class="pill" id="duePill">Due: 0</span>
    <span class="pill" id="posPill">Card 0 / 0</span>
  </header>

  <main>
    <div class="container">
      <section class="card">
        <div>
          <div class="row muted" id="meta"></div>
          <div class="front" id="front">Loading…</div>
          <div class="back" id="back"></div>
        </div>

        <div class="btnbar">
          <button id="revealBtn">Show Answer (Space)</button>
          <button id="prevBtn">⟵ Prev</button>
          <button id="nextBtn">Next ⟶</button>
          <button id="restartBtn">Restart</button>
        </div>

        <div id="gradeBar" class="btnbar hidden">
          <button class="again" id="againBtn">Again (1)</button>
          <button class="hard"  id="hardBtn">Hard (2)</button>
          <button class="good"  id="goodBtn">Good (3)</button>
          <button class="easy"  id="easyBtn">Easy (4)</button>
        </div>
      </section>

      <aside>
        <div class="panel">
          <h3 style="margin:.2rem 0 .6rem">Decks</h3>
          <div class="row" style="gap:.5rem">
            <button id="uploadDeckBtn">Upload Deck (JSON)</button>
            <button id="downloadDeckBtn">Download Current</button>
          </div>
          <div style="margin-top:.6rem">
            <label class="muted" for="deckSelect">Switch deck</label>
            <select id="deckSelect"></select>
          </div>
          <input id="fileInput" type="file" accept=".json,application/json" class="hidden">
        </div>

        <div class="panel">
          <h3 style="margin:.2rem 0 .6rem">Filters</h3>
          <label class="row"><input type="checkbox" id="dueOnly" checked> <span class="muted">Show due cards only</span></label>
        </div>
      </aside>
    </div>
  </main>

  <footer class="row" style="justify-content:space-between">
    <span class="muted">Tip: Space = Reveal/Hide, Arrow keys = Prev/Next, 1–4 = Grade.</span>
    <a href="cards.json" class="muted" target="_blank" rel="noopener">Open cards.json</a>
  </footer>

  <script>
    const APP_NS = "flashcards.srs.v2";
    const STATE_PREFIX = APP_NS + ":card:"; // STATE_PREFIX + deckName + ":" + uid
    const MANIFEST_URL = "decks.json";      // <- public decks manifest (same origin)

    let deck = { name:"Demo", cards:[] };
    let order = [];   // visible indices (filtered)
    let idx = 0;

    const $ = id => document.getElementById(id);

    // ---------- Identifiers & state ----------
    function uidFor(card){
      const s = (card.Front||"") + "::" + (card.Back||"");
      let h = 0; for (let i=0;i<s.length;i++){ h = ((h<<5)-h) + s.charCodeAt(i); h|=0; }
      return String(h);
    }
    function stKey(deckName, uid){ return STATE_PREFIX + deckName + ":" + uid; }
    function loadState(deckName, uid){
      try{ const raw = localStorage.getItem(stKey(deckName, uid)); return raw ? JSON.parse(raw) : null; }
      catch{ return null; }
    }
    function saveState(deckName, uid, st){ localStorage.setItem(stKey(deckName, uid), JSON.stringify(st)); }

    // ---------- Scheduler ----------
    function isDue(deckName, card){
      const st = loadState(deckName, uidFor(card));
      if(!st) return true;
      if(st.suspended) return false;
      if(!st.due) return true;
      return new Date(st.due) <= new Date();
    }
    function schedule(deckName, card, grade){
      const uid = uidFor(card);
      let st = loadState(deckName, uid) || { interval:0, ease:2.5, reps:0, lapses:0, phase:"new", suspended:false };
      const now = new Date();
      if(grade === "again"){
        st.lapses += 1; st.reps = Math.max(0, st.reps - 1); st.interval = 0; st.phase = "learn";
        st.due = new Date(now.getTime() + 10*60*1000).toISOString();
      } else {
        st.reps += 1; st.ease = st.ease || 2.5;
        if(grade === "hard") st.ease = Math.max(1.3, st.ease - 0.15);
        if(grade === "good") st.ease = Math.max(1.3, st.ease - 0.05);
        if(grade === "easy") st.ease = Math.min(3.2, st.ease + 0.15);
        if(st.phase === "new"){ st.interval = (grade==="easy")?3:(grade==="hard"?1:2); st.phase="review"; }
        else if(st.phase === "learn"){ st.interval = (grade==="hard")?1:2; st.phase="review"; }
        else {
          const mult = (grade==="easy")?1.5:(grade==="hard"?0.7:1.0);
          st.interval = Math.ceil(Math.max(1, st.interval) * st.ease * mult);
          st.interval = Math.max(st.interval, (grade==="easy"?3:(grade==="good"?2:1)));
        }
        st.due = new Date(now.getTime() + st.interval*24*60*60*1000).toISOString();
      }
      if(st.lapses >= 8) st.suspended = true;
      saveState(deckName, uid, st);
    }

    // ---------- View ----------
    function buildOrder(){
      const onlyDue = $("dueOnly").checked;
      const arr = [];
      for(let i=0;i<(deck.cards||[]).length;i++){
        if(onlyDue && !isDue(deck.name, deck.cards[i])) continue;
        arr.push(i);
      }
      order = arr;
      if(idx >= order.length) idx = Math.max(0, order.length-1);
      updateHeader();
    }
    function updateHeader(){
      $("deckName").textContent = "Deck: " + (deck.name || "Deck");
      $("posPill").textContent  = `Card ${ order.length ? (idx+1) : 0 } / ${ order.length }`;
      const dueCount = (deck.cards||[]).filter(c => isDue(deck.name, c)).length;
      $("duePill").textContent  = `Due: ${dueCount}`;
    }
    function currentCard(){ return order.length ? deck.cards[order[idx]] : null; }
    function render(){
      updateHeader();
      const c = currentCard(); const back = $("back"); const gradeBar = $("gradeBar");
      if(!c){
        $("front").textContent = "No cards match this view.";
        back.style.display = "none"; $("revealBtn").disabled = true; gradeBar.classList.add("hidden"); $("meta").textContent = "";
        return;
      }
      $("revealBtn").disabled = false;
      $("front").textContent = c.Front || "";
      $("back").textContent  = c.Back  || "";
      back.style.display = "none";
      $("meta").textContent = c.Tag ? ("Tag: " + c.Tag) : "";
      gradeBar.classList.add("hidden");
    }

    // ---------- Deck loading ----------
    async function loadDeck(url="cards.json"){
      const res = await fetch(url, { cache:"no-store" });
      deck = await res.json();
      idx = 0; buildOrder(); render();
    }
    function loadDeckObject(obj){
      deck = obj || {name:"Untitled", cards:[]};
      idx = 0; buildOrder(); render();
    }

    // ---------- Public manifest + Local uploads ----------
    const DECKS_KEY = APP_NS + ":userDecks";
    function getStore(){ try{ return JSON.parse(localStorage.getItem(DECKS_KEY)) || {items:[], last:"__default__"} } catch { return {items:[], last:"__default__"} } }
    function setStore(s){ localStorage.setItem(DECKS_KEY, JSON.stringify(s)); }

    async function fetchManifest(){
      try{
        const res = await fetch(MANIFEST_URL, {cache:"no-store"});
        if(!res.ok) return { decks: [] };
        const json = await res.json();
        return Array.isArray(json.decks) ? json : { decks: [] };
      }catch{ return { decks: [] }; }
    }

    async function refreshDeckSelect(){
      const manifest = await fetchManifest(); // public decks on GitHub
      const local = getStore();               // private decks in this browser

      const sel = $("deckSelect");
      const parts = [];
      // Public group (from repo)
      parts.push('<optgroup label="Public (GitHub)">');
      const pub = (manifest.decks||[]);
      if(pub.length===0) parts.push('<option disabled>(No public decks found)</option>');
      pub.forEach(d => parts.push(`<option value="${encodeURIComponent(d.file)}">${d.name}</option>`));
      parts.push('</optgroup>');
      // Local group
      parts.push('<optgroup label="Local (This device)">');
      const items = (local.items||[]);
      if(items.length===0) parts.push('<option disabled>(No local decks)</option>');
      items.forEach(it => parts.push(`<option value="local:${encodeURIComponent(it.name)}">${it.name}</option>`));
      parts.push('</optgroup>');

      sel.innerHTML = parts.join("");
      // Try to keep last selection if it exists in either list
      const last = local.last || "__default__";
      if (last === "__default__"){
        // default to first public deck if available, else load cards.json
        if (pub.length > 0){
          sel.value = encodeURIComponent(pub[0].file);
        } else {
          sel.value = encodeURIComponent("cards.json");
        }
      } else {
        // prefer matching local
        const localVal = "local:" + encodeURIComponent(last);
        if ([...sel.options].some(o=>o.value===localVal)) sel.value = localVal;
      }
    }

    $("uploadDeckBtn").onclick = () => $("fileInput").click();
    $("fileInput").onchange = e => {
      const f = e.target.files[0]; if(!f) return;
      const r = new FileReader();
      r.onload = () => {
        try{
          const obj = JSON.parse(r.result);
          const s = getStore();
          let name = obj.name || f.name.replace(/\.json$/i,"");
          const seen = new Set(s.items.map(x=>x.name));
          let k=2, base=name; while(seen.has(name)) name = base + " (" + (k++) + ")";
          s.items.push({name, data:obj}); s.last=name; setStore(s);
          refreshDeckSelect().then(()=>{
            $("deckSelect").value = "local:" + encodeURIComponent(name);
            loadDeckObject(obj);
          });
        }catch{ alert("Invalid JSON deck file."); }
        e.target.value="";
      };
      r.readAsText(f);
    };

    $("deckSelect").onchange = () => {
      const val = $("deckSelect").value;
      if (val.startsWith("local:")){
        const name = decodeURIComponent(val.slice("local:".length));
        const it = getStore().items.find(x=>x.name===name);
        if(it){ loadDeckObject(it.data); const s=getStore(); s.last=name; setStore(s); }
      } else {
        // Public deck from repo (same-origin path)
        loadDeck(decodeURIComponent(val));
        const s=getStore(); s.last="__default__"; setStore(s);
      }
    };

    $("downloadDeckBtn").onclick = () => {
      const blob = new Blob([JSON.stringify(deck,null,2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = (deck.name || "deck") + ".json";
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0);
    };

    // ---------- Actions ----------
    function showAnswer(){
      const back = $("back"); const gradeBar = $("gradeBar");
      if(back.style.display === "block"){ back.style.display = "none"; gradeBar.classList.add("hidden"); }
      else { back.style.display = "block"; gradeBar.classList.remove("hidden"); }
    }
    function next(){ if (idx < order.length-1) { idx++; render(); } }
    function prev(){ if (idx > 0) { idx--; render(); } }

    function doGrade(g){
      const c = currentCard(); if(!c) return;
      schedule(deck.name, c, g);
      buildOrder();
      if(order.length === 0){ render(); return; }
      if (idx >= order.length) idx = Math.max(0, order.length-1);
      render();
    }

    $("revealBtn").onclick = showAnswer;
    $("prevBtn").onclick   = prev;
    $("nextBtn").onclick   = next;
    $("restartBtn").onclick= () => { idx = 0; render(); };

    $("againBtn").onclick = () => doGrade("again");
    $("hardBtn").onclick  = () => doGrade("hard");
    $("goodBtn").onclick  = () => doGrade("good");
    $("easyBtn").onclick  = () => doGrade("easy");

    $("dueOnly").onchange = () => { buildOrder(); render(); };

    document.addEventListener("keydown",(e)=>{
      if(e.code === "Space"){ e.preventDefault(); showAnswer(); }
      if(e.key === "ArrowRight") next();
      if(e.key === "ArrowLeft")  prev();
      if(e.key === "1") $("againBtn").click();
      if(e.key === "2") $("hardBtn").click();
      if(e.key === "3") $("goodBtn").click();
      if(e.key === "4") $("easyBtn").click();
    });

    // ---------- Boot ----------
    document.addEventListener("DOMContentLoaded", async ()=>{
      await refreshDeckSelect();
      // If URL has ?deck=<path.json>, prefer that (handy shortcuts)
      const params = new URLSearchParams(location.search);
      const urlDeck = params.get("deck");
      if (urlDeck){ await loadDeck(urlDeck); return; }

      // Otherwise load current selection or default
      const val = $("deckSelect").value;
      if (val && !val.startsWith("local:")) await loadDeck(decodeURIComponent(val));
      else await loadDeck("cards.json");
    });
  </script>
</body>
</html>
