<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flashcards App</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; background: #f5f5f5; }
    #flashcard { background: white; padding: 20px; margin: 20px auto; width: 80%; max-width: 600px; 
                 border-radius: 10px; box-shadow: 0px 0px 10px rgba(0,0,0,0.1); cursor: pointer; }
    .hidden { display: none; }
    .controls, .filters { margin: 10px; }
    .metadata { font-size: 0.8em; color: gray; margin-top: 10px; }
    .difficulty-counts { margin: 10px; font-size: 0.9em; color: #333; }
  </style>
</head>
<body>
  <h1>Flashcards App</h1>

  <div class="filters">
    <input type="text" id="searchBox" placeholder="Global search (Q & A)">
    <input type="text" id="tagSearchBox" placeholder="Search by tag">
    <select id="difficultyFilter">
      <option value="">All difficulties</option>
      <option value="Easy">Easy</option>
      <option value="Good">Good</option>
      <option value="Hard">Hard</option>
      <option value="Again">Again</option>
      <option value="Ungraded">Ungraded</option>
    </select>
  </div>

  <div id="flashcard">
    <div id="front"></div>
    <div id="back" class="hidden"></div>
    <div class="metadata" id="metadata"></div>
  </div>

  <div class="controls">
    <button onclick="prevCard()">Previous</button>
    <button onclick="nextCard()">Next</button>
    <button onclick="flipCard()">Flip</button>
  </div>

  <div class="controls">
    <button onclick="gradeCard('Easy')">Easy</button>
    <button onclick="gradeCard('Good')">Good</button>
    <button onclick="gradeCard('Hard')">Hard</button>
    <button onclick="gradeCard('Again')">Again</button>
  </div>

  <div class="difficulty-counts" id="difficultyCounts"></div>

  <script>
    let decks = [];
    let currentDeck = [];
    let currentIndex = 0;
    let progress = {};

    async function loadDecks() {
      const res = await fetch('decks/decks.json');
      const data = await res.json();
      decks = [];
      for (let d of data.decks) {
        const deckRes = await fetch('decks/' + d.file);
        const deckData = await deckRes.json();
        deckData.cards.forEach(card => {
          card.Difficulty = card.Difficulty || null; // always start ungraded
          decks.push(card);
        });
      }
      applyFilters();
    }

    function applyFilters() {
      const query = document.getElementById('searchBox').value.toLowerCase();
      const tagQuery = document.getElementById('tagSearchBox').value.toLowerCase();
      const diffFilter = document.getElementById('difficultyFilter').value;

      currentDeck = decks.filter(c => {
        const matchesSearch = !query || 
          c.Front.toLowerCase().includes(query) || 
          c.Back.toLowerCase().includes(query);

        const matchesTag = !tagQuery || (c.Tags && c.Tags.some(tag => tag.toLowerCase().includes(tagQuery)));

        let matchesDiff = true;
        if (diffFilter) {
          if (diffFilter === "Ungraded") {
            matchesDiff = (c.Difficulty === null);
          } else {
            matchesDiff = (c.Difficulty === diffFilter);
          }
        }

        return matchesSearch && matchesTag && matchesDiff;
      });

      currentIndex = 0;
      showCard();
      updateDifficultyCounts();
    }

    function showCard() {
      if (currentDeck.length === 0) {
        document.getElementById('front').innerText = "No cards found";
        document.getElementById('back').classList.add("hidden");
        document.getElementById('metadata').innerText = "";
        return;
      }

      const card = currentDeck[currentIndex];
      document.getElementById('front').innerText = card.Front;
      document.getElementById('back').innerText = card.Back;
      document.getElementById('back').classList.add("hidden");

      document.getElementById('metadata').innerText = 
        `Chapter: ${card.Chapter || ""} | Section: ${card.Section || ""} | ` +
        `Difficulty: ${card.Difficulty || "Ungraded"} | Tags: ${(card.Tags || []).join(", ")}`;
    }

    function flipCard() {
      document.getElementById('back').classList.toggle("hidden");
    }

    function nextCard() {
      if (currentIndex < currentDeck.length - 1) currentIndex++;
      showCard();
    }

    function prevCard() {
      if (currentIndex > 0) currentIndex--;
      showCard();
    }

    function gradeCard(level) {
      const card = currentDeck[currentIndex];
      card.Difficulty = level;
      progress[card.Front] = level;
      showCard();
      updateDifficultyCounts();
    }

    function updateDifficultyCounts() {
      const counts = {Easy:0, Good:0, Hard:0, Again:0, Ungraded:0};
      for (let c of decks) {
        if (!c.Difficulty) counts.Ungraded++;
        else counts[c.Difficulty]++;
      }
      document.getElementById('difficultyCounts').innerText = 
        `Easy: ${counts.Easy} | Good: ${counts.Good} | Hard: ${counts.Hard} | Again: ${counts.Again} | Ungraded: ${counts.Ungraded}`;
    }

    document.getElementById('searchBox').addEventListener('input', applyFilters);
    document.getElementById('tagSearchBox').addEventListener('input', applyFilters);
    document.getElementById('difficultyFilter').addEventListener('change', applyFilters);

    loadDecks();
  </script>
</body>
</html>
